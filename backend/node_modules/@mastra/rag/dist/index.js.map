{"version":3,"sources":["../../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js","../src/document/prompts/format.ts","../src/document/prompts/base.ts","../src/document/prompts/prompt.ts","../src/document/schema/node.ts","../src/document/extractors/base.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/api-call-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/get-error-message.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/invalid-argument-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts","../../../node_modules/.pnpm/nanoid@3.3.11/node_modules/nanoid/non-secure/index.js","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/parse-json.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/combine-headers.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/event-source-parser-stream.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/generate-id.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/load-api-key.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/validator.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/validate-types.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/parse-provider-options.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/post-to-api.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/response-handler.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/convert-to-openai-chat-messages.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/map-openai-chat-logprobs.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/map-openai-finish-reason.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-error.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/get-response-metadata.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-prepare-tools.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-chat-language-model.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/convert-to-openai-completion-prompt.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/map-openai-completion-logprobs.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-completion-language-model.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-embedding-model.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-image-settings.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-image-model.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-transcription-model.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/responses/convert-to-openai-responses-messages.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/responses/map-openai-responses-finish-reason.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/responses/openai-responses-prepare-tools.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/responses/openai-responses-language-model.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-tools.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-speech-model.ts","../../../node_modules/.pnpm/@ai-sdk+openai@1.3.24_zod@3.25.76/node_modules/@ai-sdk/openai/src/openai-provider.ts","../src/document/extractors/types.ts","../src/document/extractors/title.ts","../src/document/extractors/summary.ts","../src/document/extractors/questions.ts","../src/document/extractors/keywords.ts","../src/document/types.ts","../src/document/transformers/text.ts","../src/document/transformers/character.ts","../src/document/transformers/html.ts","../src/document/transformers/json.ts","../src/document/transformers/latex.ts","../src/document/transformers/markdown.ts","../src/document/transformers/semantic-markdown.ts","../src/document/transformers/sentence.ts","../src/document/transformers/token.ts","../src/document/validation.ts","../src/document/document.ts","../src/rerank/relevance/cohere/index.ts","../src/rerank/relevance/mastra-agent/index.ts","../src/rerank/relevance/zeroentropy/index.ts","../src/rerank/index.ts","../src/graph-rag/index.ts","../src/tools/document-chunker.ts","../src/utils/vector-search.ts","../src/utils/default-settings.ts","../src/utils/tool-schemas.ts","../src/utils/convert-sources.ts","../src/tools/types.ts","../src/tools/graph-rag.ts","../src/tools/vector-query.ts","../src/utils/vector-prompts.ts"],"names":["parse","value","_AISDKError","name","marker","symbol","_a","_TypeValidationError","validator","SecureJSON","TypeValidationError","InvalidArgumentError","getOriginalFetch","fetch","APICallError","token","logprob","type","UnsupportedFunctionalityError","openaiTools","toolCall","z","postJsonToApi","combineHeaders","createJsonResponseHandler","createEventSourceResponseHandler","convertUint8ArrayToBase64","parseProviderOptions","_b","_c","generateId","openai","Agent","result","Language","separator","text","_separator","encodingForModel","getEncoding","rt","textSplit","node","DatabaseType","databaseSpecificParams","createTool","relevantChunks","sources"],"mappings":"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A;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAA;AAsGxB,IAAM,eAAA,GAAkB,CAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAA;AA8ExB,IAAM,aAAA,GAAgB,CAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAA;AAoJtB,IAAM,cAAA,GAAiB,CAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAA;AA8FvB,IAAM,gBAAA,GAAmB,CAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAA;AAsDzB,IAAM,cAAA,GAAiB,CAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","file":"index.js","sourcesContent":["'use strict'\n\nconst hasBuffer = typeof Buffer !== 'undefined'\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/\n\nfunction _parse (text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver\n      reviver = undefined\n    }\n  }\n\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString()\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1)\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver)\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  const protoAction = (options && options.protoAction) || 'error'\n  const constructorAction = (options && options.constructorAction) || 'error'\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj\n  }\n\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  }\n\n  // Scan result for proto keys\n  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })\n}\n\nfunction filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {\n  let next = [obj]\n\n  while (next.length) {\n    const nodes = next\n    next = []\n\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.__proto__ // eslint-disable-line no-proto\n      }\n\n      if (constructorAction !== 'ignore' &&\n          Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.constructor\n      }\n\n      for (const key in node) {\n        const value = node[key]\n        if (value && typeof value === 'object') {\n          next.push(value)\n        }\n      }\n    }\n  }\n  return obj\n}\n\nfunction parse (text, reviver, options) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, options)\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nfunction safeParse (text, reviver) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, { safe: true })\n  } catch (_e) {\n    return null\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nmodule.exports = parse\nmodule.exports.default = parse\nmodule.exports.parse = parse\nmodule.exports.safeParse = safeParse\nmodule.exports.scan = filter\n","/**\n * Formats a string by replacing placeholders with values from the provided parameters.\n * @param str The string to format.\n * @param params A record of placeholder names to their corresponding values.\n * @returns The formatted string.\n */\nexport function format(str: string, params: Record<string, string>) {\n  return str.replace(/{(\\w+)}/g, (_, k) => params[k] ?? '');\n}\n","import { format } from './format';\nimport type { BasePromptTemplateOptions, ChatMessage, PromptTemplateOptions } from './types';\n\nexport abstract class BasePromptTemplate<const TemplatesVar extends readonly string[] = string[]> {\n  templateVars: Set<string> = new Set();\n  options: Partial<Record<TemplatesVar[number] | (string & {}), string>> = {};\n\n  protected constructor(options: BasePromptTemplateOptions<TemplatesVar>) {\n    const { templateVars } = options;\n    if (templateVars) {\n      this.templateVars = new Set(templateVars);\n    }\n    if (options.options) {\n      this.options = options.options;\n    }\n  }\n\n  abstract partialFormat(\n    options: Partial<Record<TemplatesVar[number] | (string & {}), string>>,\n  ): BasePromptTemplate<TemplatesVar>;\n\n  abstract format(options?: Partial<Record<TemplatesVar[number] | (string & {}), string>>): string;\n\n  abstract formatMessages(options?: Partial<Record<TemplatesVar[number] | (string & {}), string>>): ChatMessage[];\n\n  abstract get template(): string;\n}\n\nexport class PromptTemplate<\n  const TemplatesVar extends readonly string[] = string[],\n> extends BasePromptTemplate<TemplatesVar> {\n  #template: string;\n\n  constructor(options: PromptTemplateOptions<TemplatesVar>) {\n    const { template, ...rest } = options;\n    super(rest);\n    this.#template = template;\n  }\n\n  partialFormat(options: Partial<Record<TemplatesVar[number] | (string & {}), string>>): PromptTemplate<TemplatesVar> {\n    const prompt = new PromptTemplate({\n      template: this.template,\n      templateVars: [...this.templateVars],\n      options: this.options,\n    });\n\n    prompt.options = {\n      ...prompt.options,\n      ...options,\n    };\n\n    return prompt;\n  }\n\n  format(options?: Partial<Record<TemplatesVar[number] | (string & {}), string>>): string {\n    const allOptions = {\n      ...this.options,\n      ...options,\n    } as Record<TemplatesVar[number], string>;\n\n    return format(this.template, allOptions);\n  }\n\n  formatMessages(options?: Partial<Record<TemplatesVar[number] | (string & {}), string>>): ChatMessage[] {\n    const prompt = this.format(options);\n    return [\n      {\n        role: 'user',\n        content: prompt,\n      },\n    ];\n  }\n\n  get template(): string {\n    return this.#template;\n  }\n}\n","import { PromptTemplate } from './base';\n\nexport type SummaryPrompt = PromptTemplate<['context']>;\nexport type KeywordExtractPrompt = PromptTemplate<['context', 'maxKeywords']>;\nexport type QuestionExtractPrompt = PromptTemplate<['context', 'numQuestions']>;\nexport type TitleExtractorPrompt = PromptTemplate<['context']>;\nexport type TitleCombinePrompt = PromptTemplate<['context']>;\n\nexport const defaultSummaryPrompt: SummaryPrompt = new PromptTemplate({\n  templateVars: ['context'],\n  template: `Write a summary of the following. Try to use only the information provided. Try to include as many key details as possible.\n\n\n{context}\n\n\nSUMMARY:\"\"\"\n`,\n});\n\nexport const defaultKeywordExtractPrompt: KeywordExtractPrompt = new PromptTemplate({\n  templateVars: ['maxKeywords', 'context'],\n  template: `\nSome text is provided below. Given the text, extract up to {maxKeywords} keywords from the text. Avoid stopwords.\n---------------------\n{context}\n---------------------\nProvide keywords in the following comma-separated format: 'KEYWORDS: <keywords>'\n`,\n}).partialFormat({\n  maxKeywords: '10',\n});\n\nexport const defaultQuestionExtractPrompt = new PromptTemplate({\n  templateVars: ['numQuestions', 'context'],\n  template: `(\n  \"Given the contextual informations below, generate {numQuestions} questions this context can provides specific answers to which are unlikely to be found else where. Higher-level summaries of surrounding context may be provided as well. \"\n  \"Try using these summaries to generate better questions that this context can answer.\"\n  \"---------------------\"\n  \"{context}\"\n  \"---------------------\"\n  \"Provide questions in the following format: 'QUESTIONS: <questions>'\"\n)`,\n}).partialFormat({\n  numQuestions: '5',\n});\n\nexport const defaultTitleExtractorPromptTemplate = new PromptTemplate({\n  templateVars: ['context'],\n  template: `{context}\nGive a title that summarizes all of the unique entities, titles or themes found in the context. \nTitle: `,\n});\n\nexport const defaultTitleCombinePromptTemplate = new PromptTemplate({\n  templateVars: ['context'],\n  template: `{context} \nBased on the above candidate titles and contents, what is the comprehensive title for this document? \nTitle: `,\n});\n","import { createHash, randomUUID } from 'crypto';\nimport { NodeRelationship, ObjectType } from './types';\nimport type { Metadata, RelatedNodeInfo, RelatedNodeType, BaseNodeParams, TextNodeParams } from './types';\n\n/**\n * Generic abstract class for retrievable nodes\n */\nexport abstract class BaseNode<T extends Metadata = Metadata> {\n  id_: string;\n  metadata: T;\n  relationships: Partial<Record<NodeRelationship, RelatedNodeType<T>>>;\n\n  @lazyInitHash\n  accessor hash: string = '';\n\n  protected constructor(init?: BaseNodeParams<T>) {\n    const { id_, metadata, relationships } = init || {};\n    this.id_ = id_ ?? randomUUID();\n    this.metadata = metadata ?? ({} as T);\n    this.relationships = relationships ?? {};\n  }\n\n  abstract get type(): ObjectType;\n\n  abstract getContent(): string;\n\n  abstract getMetadataStr(): string;\n\n  get sourceNode(): RelatedNodeInfo<T> | undefined {\n    const relationship = this.relationships[NodeRelationship.SOURCE];\n\n    if (Array.isArray(relationship)) {\n      throw new Error('Source object must be a single RelatedNodeInfo object');\n    }\n\n    return relationship;\n  }\n\n  get prevNode(): RelatedNodeInfo<T> | undefined {\n    const relationship = this.relationships[NodeRelationship.PREVIOUS];\n\n    if (Array.isArray(relationship)) {\n      throw new Error('Previous object must be a single RelatedNodeInfo object');\n    }\n\n    return relationship;\n  }\n\n  get nextNode(): RelatedNodeInfo<T> | undefined {\n    const relationship = this.relationships[NodeRelationship.NEXT];\n\n    if (Array.isArray(relationship)) {\n      throw new Error('Next object must be a single RelatedNodeInfo object');\n    }\n\n    return relationship;\n  }\n\n  get parentNode(): RelatedNodeInfo<T> | undefined {\n    const relationship = this.relationships[NodeRelationship.PARENT];\n\n    if (Array.isArray(relationship)) {\n      throw new Error('Parent object must be a single RelatedNodeInfo object');\n    }\n\n    return relationship;\n  }\n\n  get childNodes(): RelatedNodeInfo<T>[] | undefined {\n    const relationship = this.relationships[NodeRelationship.CHILD];\n\n    if (!Array.isArray(relationship)) {\n      throw new Error('Child object must be a an array of RelatedNodeInfo objects');\n    }\n\n    return relationship;\n  }\n\n  abstract generateHash(): string;\n}\n\n/**\n * TextNode is the default node type for text.\n */\nexport class TextNode<T extends Metadata = Metadata> extends BaseNode<T> {\n  text: string;\n\n  startCharIdx?: number;\n  endCharIdx?: number;\n  metadataSeparator: string;\n\n  constructor(init: TextNodeParams<T> = {}) {\n    super(init);\n    const { text, startCharIdx, endCharIdx, metadataSeparator } = init;\n    this.text = text ?? '';\n    if (startCharIdx) {\n      this.startCharIdx = startCharIdx;\n    }\n    if (endCharIdx) {\n      this.endCharIdx = endCharIdx;\n    }\n    this.metadataSeparator = metadataSeparator ?? '\\n';\n  }\n\n  /**\n   * Generate a hash of the text node.\n   * The ID is not part of the hash as it can change independent of content.\n   * @returns\n   */\n  generateHash() {\n    const hashFunction = createSHA256();\n    hashFunction.update(`type=${this.type}`);\n    hashFunction.update(`startCharIdx=${this.startCharIdx} endCharIdx=${this.endCharIdx}`);\n    hashFunction.update(this.getContent());\n    return hashFunction.digest();\n  }\n\n  get type() {\n    return ObjectType.TEXT;\n  }\n\n  getContent(): string {\n    const metadataStr = this.getMetadataStr().trim();\n    return `${metadataStr}\\n\\n${this.text}`.trim();\n  }\n\n  getMetadataStr(): string {\n    const usableMetadataKeys = new Set(Object.keys(this.metadata).sort());\n\n    return [...usableMetadataKeys].map(key => `${key}: ${this.metadata[key]}`).join(this.metadataSeparator);\n  }\n\n  getNodeInfo() {\n    return { start: this.startCharIdx, end: this.endCharIdx };\n  }\n\n  getText() {\n    return this.text;\n  }\n}\n\n/**\n * A document is just a special text node with a docId.\n */\nexport class Document<T extends Metadata = Metadata> extends TextNode<T> {\n  constructor(init?: TextNodeParams<T>) {\n    super(init);\n  }\n\n  get type() {\n    return ObjectType.DOCUMENT;\n  }\n}\n\nfunction lazyInitHash(\n  value: ClassAccessorDecoratorTarget<BaseNode, string>,\n  _context: ClassAccessorDecoratorContext,\n): ClassAccessorDecoratorResult<BaseNode, string> {\n  return {\n    get() {\n      const oldValue = value.get.call(this);\n      if (oldValue === '') {\n        const hash = this.generateHash();\n        value.set.call(this, hash);\n      }\n      return value.get.call(this);\n    },\n    set(newValue: string) {\n      value.set.call(this, newValue);\n    },\n    init(value: string): string {\n      return value;\n    },\n  };\n}\n\nfunction createSHA256() {\n  const hash = createHash('sha256');\n  return {\n    update(data: string | Uint8Array): void {\n      hash.update(data);\n    },\n    digest() {\n      return hash.digest('base64');\n    },\n  };\n}\n","import type { BaseNode } from '../schema';\n\n/*\n * Abstract class for all extractors.\n */\nexport abstract class BaseExtractor {\n  isTextNodeOnly: boolean = true;\n\n  abstract extract(nodes: BaseNode[]): Promise<Record<string, any>[]>;\n\n  /**\n   *\n   * @param nodes Nodes to extract metadata from.\n   * @returns Metadata extracted from the nodes.\n   */\n  async processNodes(nodes: BaseNode[]): Promise<BaseNode[]> {\n    let newNodes: BaseNode[] = nodes;\n\n    const curMetadataList = await this.extract(newNodes);\n\n    for (const idx in newNodes) {\n      newNodes[idx]!.metadata = {\n        ...newNodes[idx]!.metadata,\n        ...curMetadataList[idx],\n      };\n    }\n\n    return newNodes;\n  }\n}\n","/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A function argument is invalid.\n */\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly argument: string;\n\n  constructor({\n    message,\n    cause,\n    argument,\n  }: {\n    argument: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.argument = argument;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({\n    prompt,\n    message,\n    cause,\n  }: {\n    prompt: unknown;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message: `Invalid prompt: ${message}`, cause });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n// TODO v5: rename to ParseError\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`,\n  }: {\n    functionality: string;\n    message?: string;\n  }) {\n    super({ name, message });\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nexport { nanoid, customAlphabet }\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n","export type EventSourceChunk = {\n  event: string | undefined;\n  data: string;\n  id?: string;\n  retry?: number;\n};\n\nexport function createEventSourceParserStream() {\n  let buffer = '';\n  let event: string | undefined = undefined;\n  let data: string[] = [];\n  let lastEventId: string | undefined = undefined;\n  let retry: number | undefined = undefined;\n\n  function parseLine(\n    line: string,\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    // Empty line means dispatch the event\n    if (line === '') {\n      dispatchEvent(controller);\n      return;\n    }\n\n    // Comments start with colon\n    if (line.startsWith(':')) {\n      return;\n    }\n\n    // Field parsing\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      // field with no value\n      handleField(line, '');\n      return;\n    }\n\n    const field = line.slice(0, colonIndex);\n    // If there's a space after the colon, it should be ignored\n    const valueStart = colonIndex + 1;\n    const value =\n      valueStart < line.length && line[valueStart] === ' '\n        ? line.slice(valueStart + 1)\n        : line.slice(valueStart);\n\n    handleField(field, value);\n  }\n\n  function dispatchEvent(\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join('\\n'),\n        id: lastEventId,\n        retry,\n      });\n\n      // Reset data but keep lastEventId as per spec\n      data = [];\n      event = undefined;\n      retry = undefined;\n    }\n  }\n\n  function handleField(field: string, value: string) {\n    switch (field) {\n      case 'event':\n        event = value;\n        break;\n      case 'data':\n        data.push(value);\n        break;\n      case 'id':\n        lastEventId = value;\n        break;\n      case 'retry':\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n\n  return new TransformStream<string, EventSourceChunk>({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n\n      buffer = incompleteLine;\n\n      // using for loop for performance\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    },\n  });\n}\n\n// performance: send in already scanned buffer separately, do not scan again\nfunction splitLines(buffer: string, chunk: string) {\n  const lines: Array<string> = [];\n  let currentLine = buffer;\n\n  // using for loop for performance\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n\n    // order is performance-optimized\n    if (char === '\\n') {\n      // Standalone LF\n      lines.push(currentLine);\n      currentLine = '';\n    } else if (char === '\\r') {\n      lines.push(currentLine);\n      currentLine = '';\n      if (chunk[i] === '\\n') {\n        i++; // CRLF case: Skip the LF character\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n\n  return { lines, incompleteLine: currentLine };\n}\n","/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n","/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n","export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n","import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n","import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from './validate-types';\nimport { z } from 'zod';\n\nexport function parseProviderOptions<T>({\n  provider,\n  providerOptions,\n  schema,\n}: {\n  provider: string;\n  providerOptions: Record<string, unknown> | undefined;\n  schema: z.ZodSchema<T>;\n}): T | undefined {\n  if (providerOptions?.[provider] == null) {\n    return undefined;\n  }\n\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema,\n  });\n\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError({\n      argument: 'providerOptions',\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error,\n    });\n  }\n\n  return parsedProviderOptions.value;\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postFormDataToApi = async <T>({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  formData: FormData;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers,\n    body: {\n      content: formData,\n      values: Object.fromEntries((formData as any).entries()),\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport { ZodSchema } from 'zod';\nimport {\n  createEventSourceParserStream,\n  EventSourceChunk,\n} from './event-source-parser-stream';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { parseJSON, ParseResult, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(createEventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<EventSourceChunk, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n","// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n","export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n","import {\n  LanguageModelV1CallWarning,\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport { OpenAIChatPrompt } from './openai-chat-prompt';\n\nexport function convertToOpenAIChatMessages({\n  prompt,\n  useLegacyFunctionCalling = false,\n  systemMessageMode = 'system',\n}: {\n  prompt: LanguageModelV1Prompt;\n  useLegacyFunctionCalling?: boolean;\n  systemMessageMode?: 'system' | 'developer' | 'remove';\n}): {\n  messages: OpenAIChatPrompt;\n  warnings: Array<LanguageModelV1CallWarning>;\n} {\n  const messages: OpenAIChatPrompt = [];\n  const warnings: Array<LanguageModelV1CallWarning> = [];\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        switch (systemMessageMode) {\n          case 'system': {\n            messages.push({ role: 'system', content });\n            break;\n          }\n          case 'developer': {\n            messages.push({ role: 'developer', content });\n            break;\n          }\n          case 'remove': {\n            warnings.push({\n              type: 'other',\n              message: 'system messages are removed for this model',\n            });\n            break;\n          }\n          default: {\n            const _exhaustiveCheck: never = systemMessageMode;\n            throw new Error(\n              `Unsupported system message mode: ${_exhaustiveCheck}`,\n            );\n          }\n        }\n        break;\n      }\n\n      case 'user': {\n        if (content.length === 1 && content[0].type === 'text') {\n          messages.push({ role: 'user', content: content[0].text });\n          break;\n        }\n\n        messages.push({\n          role: 'user',\n          content: content.map((part, index) => {\n            switch (part.type) {\n              case 'text': {\n                return { type: 'text', text: part.text };\n              }\n              case 'image': {\n                return {\n                  type: 'image_url',\n                  image_url: {\n                    url:\n                      part.image instanceof URL\n                        ? part.image.toString()\n                        : `data:${\n                            part.mimeType ?? 'image/jpeg'\n                          };base64,${convertUint8ArrayToBase64(part.image)}`,\n\n                    // OpenAI specific extension: image detail\n                    detail: part.providerMetadata?.openai?.imageDetail,\n                  },\n                };\n              }\n              case 'file': {\n                if (part.data instanceof URL) {\n                  throw new UnsupportedFunctionalityError({\n                    functionality:\n                      \"'File content parts with URL data' functionality not supported.\",\n                  });\n                }\n\n                switch (part.mimeType) {\n                  case 'audio/wav': {\n                    return {\n                      type: 'input_audio',\n                      input_audio: { data: part.data, format: 'wav' },\n                    };\n                  }\n                  case 'audio/mp3':\n                  case 'audio/mpeg': {\n                    return {\n                      type: 'input_audio',\n                      input_audio: { data: part.data, format: 'mp3' },\n                    };\n                  }\n                  case 'application/pdf': {\n                    return {\n                      type: 'file',\n                      file: {\n                        filename: part.filename ?? `part-${index}.pdf`,\n                        file_data: `data:application/pdf;base64,${part.data}`,\n                      },\n                    };\n                  }\n                  default: {\n                    throw new UnsupportedFunctionalityError({\n                      functionality: `File content part type ${part.mimeType} in user messages`,\n                    });\n                  }\n                }\n              }\n            }\n          }),\n        });\n\n        break;\n      }\n\n      case 'assistant': {\n        let text = '';\n        const toolCalls: Array<{\n          id: string;\n          type: 'function';\n          function: { name: string; arguments: string };\n        }> = [];\n\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              text += part.text;\n              break;\n            }\n            case 'tool-call': {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: 'function',\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.args),\n                },\n              });\n              break;\n            }\n          }\n        }\n\n        if (useLegacyFunctionCalling) {\n          if (toolCalls.length > 1) {\n            throw new UnsupportedFunctionalityError({\n              functionality:\n                'useLegacyFunctionCalling with multiple tool calls in one message',\n            });\n          }\n\n          messages.push({\n            role: 'assistant',\n            content: text,\n            function_call:\n              toolCalls.length > 0 ? toolCalls[0].function : undefined,\n          });\n        } else {\n          messages.push({\n            role: 'assistant',\n            content: text,\n            tool_calls: toolCalls.length > 0 ? toolCalls : undefined,\n          });\n        }\n\n        break;\n      }\n\n      case 'tool': {\n        for (const toolResponse of content) {\n          if (useLegacyFunctionCalling) {\n            messages.push({\n              role: 'function',\n              name: toolResponse.toolName,\n              content: JSON.stringify(toolResponse.result),\n            });\n          } else {\n            messages.push({\n              role: 'tool',\n              tool_call_id: toolResponse.toolCallId,\n              content: JSON.stringify(toolResponse.result),\n            });\n          }\n        }\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return { messages, warnings };\n}\n","import { LanguageModelV1LogProbs } from '@ai-sdk/provider';\n\ntype OpenAIChatLogProbs = {\n  content:\n    | {\n        token: string;\n        logprob: number;\n        top_logprobs:\n          | {\n              token: string;\n              logprob: number;\n            }[]\n          | null;\n      }[]\n    | null;\n};\n\nexport function mapOpenAIChatLogProbsOutput(\n  logprobs: OpenAIChatLogProbs | null | undefined,\n): LanguageModelV1LogProbs | undefined {\n  return (\n    logprobs?.content?.map(({ token, logprob, top_logprobs }) => ({\n      token,\n      logprob,\n      topLogprobs: top_logprobs\n        ? top_logprobs.map(({ token, logprob }) => ({\n            token,\n            logprob,\n          }))\n        : [],\n    })) ?? undefined\n  );\n}\n","import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\nexport function mapOpenAIFinishReason(\n  finishReason: string | null | undefined,\n): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop';\n    case 'length':\n      return 'length';\n    case 'content_filter':\n      return 'content-filter';\n    case 'function_call':\n    case 'tool_calls':\n      return 'tool-calls';\n    default:\n      return 'unknown';\n  }\n}\n","import { z } from 'zod';\nimport { createJsonErrorResponseHandler } from '@ai-sdk/provider-utils';\n\nexport const openaiErrorDataSchema = z.object({\n  error: z.object({\n    message: z.string(),\n\n    // The additional information below is handled loosely to support\n    // OpenAI-compatible providers that have slightly different error\n    // responses:\n    type: z.string().nullish(),\n    param: z.any().nullish(),\n    code: z.union([z.string(), z.number()]).nullish(),\n  }),\n});\n\nexport type OpenAIErrorData = z.infer<typeof openaiErrorDataSchema>;\n\nexport const openaiFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: openaiErrorDataSchema,\n  errorToMessage: data => data.error.message,\n});\n","export function getResponseMetadata({\n  id,\n  model,\n  created,\n}: {\n  id?: string | undefined | null;\n  created?: number | undefined | null;\n  model?: string | undefined | null;\n}) {\n  return {\n    id: id ?? undefined,\n    modelId: model ?? undefined,\n    timestamp: created != null ? new Date(created * 1000) : undefined,\n  };\n}\n","import {\n  JSONSchema7,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport function prepareTools({\n  mode,\n  useLegacyFunctionCalling = false,\n  structuredOutputs,\n}: {\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  };\n  useLegacyFunctionCalling: boolean | undefined;\n  structuredOutputs: boolean;\n}): {\n  tools?: {\n    type: 'function';\n    function: {\n      name: string;\n      description: string | undefined;\n      parameters: JSONSchema7;\n      strict?: boolean;\n    };\n  }[];\n  tool_choice?:\n    | 'auto'\n    | 'none'\n    | 'required'\n    | { type: 'function'; function: { name: string } };\n\n  // legacy support\n  functions?: {\n    name: string;\n    description: string | undefined;\n    parameters: JSONSchema7;\n  }[];\n  function_call?: { name: string };\n  toolWarnings: Array<LanguageModelV1CallWarning>;\n} {\n  // when the tools array is empty, change it to undefined to prevent errors:\n  const tools = mode.tools?.length ? mode.tools : undefined;\n\n  const toolWarnings: LanguageModelV1CallWarning[] = [];\n\n  if (tools == null) {\n    return { tools: undefined, tool_choice: undefined, toolWarnings };\n  }\n\n  const toolChoice = mode.toolChoice;\n\n  if (useLegacyFunctionCalling) {\n    const openaiFunctions: Array<{\n      name: string;\n      description: string | undefined;\n      parameters: JSONSchema7;\n    }> = [];\n\n    for (const tool of tools) {\n      if (tool.type === 'provider-defined') {\n        toolWarnings.push({ type: 'unsupported-tool', tool });\n      } else {\n        openaiFunctions.push({\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n        });\n      }\n    }\n\n    if (toolChoice == null) {\n      return {\n        functions: openaiFunctions,\n        function_call: undefined,\n        toolWarnings,\n      };\n    }\n\n    const type = toolChoice.type;\n\n    switch (type) {\n      case 'auto':\n      case 'none':\n      case undefined:\n        return {\n          functions: openaiFunctions,\n          function_call: undefined,\n          toolWarnings,\n        };\n      case 'required':\n        throw new UnsupportedFunctionalityError({\n          functionality: 'useLegacyFunctionCalling and toolChoice: required',\n        });\n      default:\n        return {\n          functions: openaiFunctions,\n          function_call: { name: toolChoice.toolName },\n          toolWarnings,\n        };\n    }\n  }\n\n  const openaiTools: Array<{\n    type: 'function';\n    function: {\n      name: string;\n      description: string | undefined;\n      parameters: JSONSchema7;\n      strict: boolean | undefined;\n    };\n  }> = [];\n\n  for (const tool of tools) {\n    if (tool.type === 'provider-defined') {\n      toolWarnings.push({ type: 'unsupported-tool', tool });\n    } else {\n      openaiTools.push({\n        type: 'function',\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n          strict: structuredOutputs ? true : undefined,\n        },\n      });\n    }\n  }\n\n  if (toolChoice == null) {\n    return { tools: openaiTools, tool_choice: undefined, toolWarnings };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n    case 'none':\n    case 'required':\n      return { tools: openaiTools, tool_choice: type, toolWarnings };\n    case 'tool':\n      return {\n        tools: openaiTools,\n        tool_choice: {\n          type: 'function',\n          function: {\n            name: toolChoice.toolName,\n          },\n        },\n        toolWarnings,\n      };\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n","import {\n  InvalidResponseDataError,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1LogProbs,\n  LanguageModelV1ProviderMetadata,\n  LanguageModelV1StreamPart,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  generateId,\n  isParsableJson,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { convertToOpenAIChatMessages } from './convert-to-openai-chat-messages';\nimport { mapOpenAIChatLogProbsOutput } from './map-openai-chat-logprobs';\nimport { mapOpenAIFinishReason } from './map-openai-finish-reason';\nimport { OpenAIChatModelId, OpenAIChatSettings } from './openai-chat-settings';\nimport {\n  openaiErrorDataSchema,\n  openaiFailedResponseHandler,\n} from './openai-error';\nimport { getResponseMetadata } from './get-response-metadata';\nimport { prepareTools } from './openai-prepare-tools';\n\ntype OpenAIChatConfig = {\n  provider: string;\n  compatibility: 'strict' | 'compatible';\n  headers: () => Record<string, string | undefined>;\n  url: (options: { modelId: string; path: string }) => string;\n  fetch?: FetchFunction;\n};\n\nexport class OpenAIChatLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n\n  readonly modelId: OpenAIChatModelId;\n  readonly settings: OpenAIChatSettings;\n\n  private readonly config: OpenAIChatConfig;\n\n  constructor(\n    modelId: OpenAIChatModelId,\n    settings: OpenAIChatSettings,\n    config: OpenAIChatConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get supportsStructuredOutputs(): boolean {\n    // enable structured outputs for reasoning models by default:\n    // TODO in the next major version, remove this and always use json mode for models\n    // that support structured outputs (blacklist other models)\n    return this.settings.structuredOutputs ?? isReasoningModel(this.modelId);\n  }\n\n  get defaultObjectGenerationMode() {\n    // audio models don't support structured outputs:\n    if (isAudioModel(this.modelId)) {\n      return 'tool';\n    }\n\n    return this.supportsStructuredOutputs ? 'json' : 'tool';\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  get supportsImageUrls(): boolean {\n    // image urls can be sent if downloadImages is disabled (default):\n    return !this.settings.downloadImages;\n  }\n\n  private getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    providerMetadata,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const type = mode.type;\n\n    const warnings: LanguageModelV1CallWarning[] = [];\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (\n      responseFormat?.type === 'json' &&\n      responseFormat.schema != null &&\n      !this.supportsStructuredOutputs\n    ) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details:\n          'JSON response format schema is only supported with structuredOutputs',\n      });\n    }\n\n    const useLegacyFunctionCalling = this.settings.useLegacyFunctionCalling;\n\n    if (useLegacyFunctionCalling && this.settings.parallelToolCalls === true) {\n      throw new UnsupportedFunctionalityError({\n        functionality: 'useLegacyFunctionCalling with parallelToolCalls',\n      });\n    }\n\n    if (useLegacyFunctionCalling && this.supportsStructuredOutputs) {\n      throw new UnsupportedFunctionalityError({\n        functionality: 'structuredOutputs with useLegacyFunctionCalling',\n      });\n    }\n\n    const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages(\n      {\n        prompt,\n        useLegacyFunctionCalling,\n        systemMessageMode: getSystemMessageMode(this.modelId),\n      },\n    );\n\n    warnings.push(...messageWarnings);\n\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs:\n        this.settings.logprobs === true ||\n        typeof this.settings.logprobs === 'number'\n          ? true\n          : undefined,\n      top_logprobs:\n        typeof this.settings.logprobs === 'number'\n          ? this.settings.logprobs\n          : typeof this.settings.logprobs === 'boolean'\n            ? this.settings.logprobs\n              ? 0\n              : undefined\n            : undefined,\n      user: this.settings.user,\n      parallel_tool_calls: this.settings.parallelToolCalls,\n\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      response_format:\n        responseFormat?.type === 'json'\n          ? this.supportsStructuredOutputs && responseFormat.schema != null\n            ? {\n                type: 'json_schema',\n                json_schema: {\n                  schema: responseFormat.schema,\n                  strict: true,\n                  name: responseFormat.name ?? 'response',\n                  description: responseFormat.description,\n                },\n              }\n            : { type: 'json_object' }\n          : undefined,\n      stop: stopSequences,\n      seed,\n\n      // openai specific settings:\n      // TODO remove in next major version; we auto-map maxTokens now\n      max_completion_tokens: providerMetadata?.openai?.maxCompletionTokens,\n      store: providerMetadata?.openai?.store,\n      metadata: providerMetadata?.openai?.metadata,\n      prediction: providerMetadata?.openai?.prediction,\n      reasoning_effort:\n        providerMetadata?.openai?.reasoningEffort ??\n        this.settings.reasoningEffort,\n\n      // messages:\n      messages,\n    };\n\n    if (isReasoningModel(this.modelId)) {\n      // remove unsupported settings for reasoning models\n      // see https://platform.openai.com/docs/guides/reasoning#limitations\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'temperature',\n          details: 'temperature is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.top_p != null) {\n        baseArgs.top_p = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'topP',\n          details: 'topP is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.frequency_penalty != null) {\n        baseArgs.frequency_penalty = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'frequencyPenalty',\n          details: 'frequencyPenalty is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.presence_penalty != null) {\n        baseArgs.presence_penalty = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'presencePenalty',\n          details: 'presencePenalty is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.logit_bias != null) {\n        baseArgs.logit_bias = undefined;\n        warnings.push({\n          type: 'other',\n          message: 'logitBias is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.logprobs != null) {\n        baseArgs.logprobs = undefined;\n        warnings.push({\n          type: 'other',\n          message: 'logprobs is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.top_logprobs != null) {\n        baseArgs.top_logprobs = undefined;\n        warnings.push({\n          type: 'other',\n          message: 'topLogprobs is not supported for reasoning models',\n        });\n      }\n\n      // reasoning models use max_completion_tokens instead of max_tokens:\n      if (baseArgs.max_tokens != null) {\n        if (baseArgs.max_completion_tokens == null) {\n          baseArgs.max_completion_tokens = baseArgs.max_tokens;\n        }\n        baseArgs.max_tokens = undefined;\n      }\n    } else if (\n      this.modelId.startsWith('gpt-4o-search-preview') ||\n      this.modelId.startsWith('gpt-4o-mini-search-preview')\n    ) {\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'temperature',\n          details:\n            'temperature is not supported for the search preview models and has been removed.',\n        });\n      }\n    }\n    switch (type) {\n      case 'regular': {\n        const { tools, tool_choice, functions, function_call, toolWarnings } =\n          prepareTools({\n            mode,\n            useLegacyFunctionCalling,\n            structuredOutputs: this.supportsStructuredOutputs,\n          });\n\n        return {\n          args: {\n            ...baseArgs,\n            tools,\n            tool_choice,\n            functions,\n            function_call,\n          },\n          warnings: [...warnings, ...toolWarnings],\n        };\n      }\n\n      case 'object-json': {\n        return {\n          args: {\n            ...baseArgs,\n            response_format:\n              this.supportsStructuredOutputs && mode.schema != null\n                ? {\n                    type: 'json_schema',\n                    json_schema: {\n                      schema: mode.schema,\n                      strict: true,\n                      name: mode.name ?? 'response',\n                      description: mode.description,\n                    },\n                  }\n                : { type: 'json_object' },\n          },\n          warnings,\n        };\n      }\n\n      case 'object-tool': {\n        return {\n          args: useLegacyFunctionCalling\n            ? {\n                ...baseArgs,\n                function_call: {\n                  name: mode.tool.name,\n                },\n                functions: [\n                  {\n                    name: mode.tool.name,\n                    description: mode.tool.description,\n                    parameters: mode.tool.parameters,\n                  },\n                ],\n              }\n            : {\n                ...baseArgs,\n                tool_choice: {\n                  type: 'function',\n                  function: { name: mode.tool.name },\n                },\n                tools: [\n                  {\n                    type: 'function',\n                    function: {\n                      name: mode.tool.name,\n                      description: mode.tool.description,\n                      parameters: mode.tool.parameters,\n                      strict: this.supportsStructuredOutputs ? true : undefined,\n                    },\n                  },\n                ],\n              },\n          warnings,\n        };\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args: body, warnings } = this.getArgs(options);\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: '/chat/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiChatResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = body;\n    const choice = response.choices[0];\n\n    // provider metadata:\n    const completionTokenDetails = response.usage?.completion_tokens_details;\n    const promptTokenDetails = response.usage?.prompt_tokens_details;\n    const providerMetadata: LanguageModelV1ProviderMetadata = { openai: {} };\n    if (completionTokenDetails?.reasoning_tokens != null) {\n      providerMetadata.openai.reasoningTokens =\n        completionTokenDetails?.reasoning_tokens;\n    }\n    if (completionTokenDetails?.accepted_prediction_tokens != null) {\n      providerMetadata.openai.acceptedPredictionTokens =\n        completionTokenDetails?.accepted_prediction_tokens;\n    }\n    if (completionTokenDetails?.rejected_prediction_tokens != null) {\n      providerMetadata.openai.rejectedPredictionTokens =\n        completionTokenDetails?.rejected_prediction_tokens;\n    }\n    if (promptTokenDetails?.cached_tokens != null) {\n      providerMetadata.openai.cachedPromptTokens =\n        promptTokenDetails?.cached_tokens;\n    }\n\n    return {\n      text: choice.message.content ?? undefined,\n      toolCalls:\n        this.settings.useLegacyFunctionCalling && choice.message.function_call\n          ? [\n              {\n                toolCallType: 'function',\n                toolCallId: generateId(),\n                toolName: choice.message.function_call.name,\n                args: choice.message.function_call.arguments,\n              },\n            ]\n          : choice.message.tool_calls?.map(toolCall => ({\n              toolCallType: 'function',\n              toolCallId: toolCall.id ?? generateId(),\n              toolName: toolCall.function.name,\n              args: toolCall.function.arguments!,\n            })),\n      finishReason: mapOpenAIFinishReason(choice.finish_reason),\n      usage: {\n        promptTokens: response.usage?.prompt_tokens ?? NaN,\n        completionTokens: response.usage?.completion_tokens ?? NaN,\n      },\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      request: { body: JSON.stringify(body) },\n      response: getResponseMetadata(response),\n      warnings,\n      logprobs: mapOpenAIChatLogProbsOutput(choice.logprobs),\n      providerMetadata,\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    if (this.settings.simulateStreaming) {\n      const result = await this.doGenerate(options);\n\n      const simulatedStream = new ReadableStream<LanguageModelV1StreamPart>({\n        start(controller) {\n          controller.enqueue({ type: 'response-metadata', ...result.response });\n          if (result.text) {\n            controller.enqueue({\n              type: 'text-delta',\n              textDelta: result.text,\n            });\n          }\n          if (result.toolCalls) {\n            for (const toolCall of result.toolCalls) {\n              controller.enqueue({\n                type: 'tool-call-delta',\n                toolCallType: 'function',\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                argsTextDelta: toolCall.args,\n              });\n\n              controller.enqueue({\n                type: 'tool-call',\n                ...toolCall,\n              });\n            }\n          }\n          controller.enqueue({\n            type: 'finish',\n            finishReason: result.finishReason,\n            usage: result.usage,\n            logprobs: result.logprobs,\n            providerMetadata: result.providerMetadata,\n          });\n          controller.close();\n        },\n      });\n      return {\n        stream: simulatedStream,\n        rawCall: result.rawCall,\n        rawResponse: result.rawResponse,\n        warnings: result.warnings,\n      };\n    }\n\n    const { args, warnings } = this.getArgs(options);\n\n    const body = {\n      ...args,\n      stream: true,\n\n      // only include stream_options when in strict compatibility mode:\n      stream_options:\n        this.config.compatibility === 'strict'\n          ? { include_usage: true }\n          : undefined,\n    };\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/chat/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        openaiChatChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = args;\n\n    const toolCalls: Array<{\n      id: string;\n      type: 'function';\n      function: {\n        name: string;\n        arguments: string;\n      };\n      hasFinished: boolean;\n    }> = [];\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let usage: {\n      promptTokens: number | undefined;\n      completionTokens: number | undefined;\n    } = {\n      promptTokens: undefined,\n      completionTokens: undefined,\n    };\n    let logprobs: LanguageModelV1LogProbs;\n    let isFirstChunk = true;\n\n    const { useLegacyFunctionCalling } = this.settings;\n\n    const providerMetadata: LanguageModelV1ProviderMetadata = { openai: {} };\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof openaiChatChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            // handle error chunks:\n            if ('error' in value) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: value.error });\n              return;\n            }\n\n            if (isFirstChunk) {\n              isFirstChunk = false;\n\n              controller.enqueue({\n                type: 'response-metadata',\n                ...getResponseMetadata(value),\n              });\n            }\n\n            if (value.usage != null) {\n              const {\n                prompt_tokens,\n                completion_tokens,\n                prompt_tokens_details,\n                completion_tokens_details,\n              } = value.usage;\n\n              usage = {\n                promptTokens: prompt_tokens ?? undefined,\n                completionTokens: completion_tokens ?? undefined,\n              };\n\n              if (completion_tokens_details?.reasoning_tokens != null) {\n                providerMetadata.openai.reasoningTokens =\n                  completion_tokens_details?.reasoning_tokens;\n              }\n              if (\n                completion_tokens_details?.accepted_prediction_tokens != null\n              ) {\n                providerMetadata.openai.acceptedPredictionTokens =\n                  completion_tokens_details?.accepted_prediction_tokens;\n              }\n              if (\n                completion_tokens_details?.rejected_prediction_tokens != null\n              ) {\n                providerMetadata.openai.rejectedPredictionTokens =\n                  completion_tokens_details?.rejected_prediction_tokens;\n              }\n              if (prompt_tokens_details?.cached_tokens != null) {\n                providerMetadata.openai.cachedPromptTokens =\n                  prompt_tokens_details?.cached_tokens;\n              }\n            }\n\n            const choice = value.choices[0];\n\n            if (choice?.finish_reason != null) {\n              finishReason = mapOpenAIFinishReason(choice.finish_reason);\n            }\n\n            if (choice?.delta == null) {\n              return;\n            }\n\n            const delta = choice.delta;\n\n            if (delta.content != null) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: delta.content,\n              });\n            }\n\n            const mappedLogprobs = mapOpenAIChatLogProbsOutput(\n              choice?.logprobs,\n            );\n            if (mappedLogprobs?.length) {\n              if (logprobs === undefined) logprobs = [];\n              logprobs.push(...mappedLogprobs);\n            }\n\n            const mappedToolCalls: typeof delta.tool_calls =\n              useLegacyFunctionCalling && delta.function_call != null\n                ? [\n                    {\n                      type: 'function',\n                      id: generateId(),\n                      function: delta.function_call,\n                      index: 0,\n                    },\n                  ]\n                : delta.tool_calls;\n\n            if (mappedToolCalls != null) {\n              for (const toolCallDelta of mappedToolCalls) {\n                const index = toolCallDelta.index;\n\n                // Tool call start. OpenAI returns all information except the arguments in the first chunk.\n                if (toolCalls[index] == null) {\n                  if (toolCallDelta.type !== 'function') {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function' type.`,\n                    });\n                  }\n\n                  if (toolCallDelta.id == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'id' to be a string.`,\n                    });\n                  }\n\n                  if (toolCallDelta.function?.name == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function.name' to be a string.`,\n                    });\n                  }\n\n                  toolCalls[index] = {\n                    id: toolCallDelta.id,\n                    type: 'function',\n                    function: {\n                      name: toolCallDelta.function.name,\n                      arguments: toolCallDelta.function.arguments ?? '',\n                    },\n                    hasFinished: false,\n                  };\n\n                  const toolCall = toolCalls[index];\n\n                  if (\n                    toolCall.function?.name != null &&\n                    toolCall.function?.arguments != null\n                  ) {\n                    // send delta if the argument text has already started:\n                    if (toolCall.function.arguments.length > 0) {\n                      controller.enqueue({\n                        type: 'tool-call-delta',\n                        toolCallType: 'function',\n                        toolCallId: toolCall.id,\n                        toolName: toolCall.function.name,\n                        argsTextDelta: toolCall.function.arguments,\n                      });\n                    }\n\n                    // check if tool call is complete\n                    // (some providers send the full tool call in one chunk):\n                    if (isParsableJson(toolCall.function.arguments)) {\n                      controller.enqueue({\n                        type: 'tool-call',\n                        toolCallType: 'function',\n                        toolCallId: toolCall.id ?? generateId(),\n                        toolName: toolCall.function.name,\n                        args: toolCall.function.arguments,\n                      });\n                      toolCall.hasFinished = true;\n                    }\n                  }\n\n                  continue;\n                }\n\n                // existing tool call, merge if not finished\n                const toolCall = toolCalls[index];\n\n                if (toolCall.hasFinished) {\n                  continue;\n                }\n\n                if (toolCallDelta.function?.arguments != null) {\n                  toolCall.function!.arguments +=\n                    toolCallDelta.function?.arguments ?? '';\n                }\n\n                // send delta\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallType: 'function',\n                  toolCallId: toolCall.id,\n                  toolName: toolCall.function.name,\n                  argsTextDelta: toolCallDelta.function.arguments ?? '',\n                });\n\n                // check if tool call is complete\n                if (\n                  toolCall.function?.name != null &&\n                  toolCall.function?.arguments != null &&\n                  isParsableJson(toolCall.function.arguments)\n                ) {\n                  controller.enqueue({\n                    type: 'tool-call',\n                    toolCallType: 'function',\n                    toolCallId: toolCall.id ?? generateId(),\n                    toolName: toolCall.function.name,\n                    args: toolCall.function.arguments,\n                  });\n                  toolCall.hasFinished = true;\n                }\n              }\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              logprobs,\n              usage: {\n                promptTokens: usage.promptTokens ?? NaN,\n                completionTokens: usage.completionTokens ?? NaN,\n              },\n              ...(providerMetadata != null ? { providerMetadata } : {}),\n            });\n          },\n        }),\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      request: { body: JSON.stringify(body) },\n      warnings,\n    };\n  }\n}\n\nconst openaiTokenUsageSchema = z\n  .object({\n    prompt_tokens: z.number().nullish(),\n    completion_tokens: z.number().nullish(),\n    prompt_tokens_details: z\n      .object({\n        cached_tokens: z.number().nullish(),\n      })\n      .nullish(),\n    completion_tokens_details: z\n      .object({\n        reasoning_tokens: z.number().nullish(),\n        accepted_prediction_tokens: z.number().nullish(),\n        rejected_prediction_tokens: z.number().nullish(),\n      })\n      .nullish(),\n  })\n  .nullish();\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiChatResponseSchema = z.object({\n  id: z.string().nullish(),\n  created: z.number().nullish(),\n  model: z.string().nullish(),\n  choices: z.array(\n    z.object({\n      message: z.object({\n        role: z.literal('assistant').nullish(),\n        content: z.string().nullish(),\n        function_call: z\n          .object({\n            arguments: z.string(),\n            name: z.string(),\n          })\n          .nullish(),\n        tool_calls: z\n          .array(\n            z.object({\n              id: z.string().nullish(),\n              type: z.literal('function'),\n              function: z.object({\n                name: z.string(),\n                arguments: z.string(),\n              }),\n            }),\n          )\n          .nullish(),\n      }),\n      index: z.number(),\n      logprobs: z\n        .object({\n          content: z\n            .array(\n              z.object({\n                token: z.string(),\n                logprob: z.number(),\n                top_logprobs: z.array(\n                  z.object({\n                    token: z.string(),\n                    logprob: z.number(),\n                  }),\n                ),\n              }),\n            )\n            .nullable(),\n        })\n        .nullish(),\n      finish_reason: z.string().nullish(),\n    }),\n  ),\n  usage: openaiTokenUsageSchema,\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiChatChunkSchema = z.union([\n  z.object({\n    id: z.string().nullish(),\n    created: z.number().nullish(),\n    model: z.string().nullish(),\n    choices: z.array(\n      z.object({\n        delta: z\n          .object({\n            role: z.enum(['assistant']).nullish(),\n            content: z.string().nullish(),\n            function_call: z\n              .object({\n                name: z.string().optional(),\n                arguments: z.string().optional(),\n              })\n              .nullish(),\n            tool_calls: z\n              .array(\n                z.object({\n                  index: z.number(),\n                  id: z.string().nullish(),\n                  type: z.literal('function').nullish(),\n                  function: z.object({\n                    name: z.string().nullish(),\n                    arguments: z.string().nullish(),\n                  }),\n                }),\n              )\n              .nullish(),\n          })\n          .nullish(),\n        logprobs: z\n          .object({\n            content: z\n              .array(\n                z.object({\n                  token: z.string(),\n                  logprob: z.number(),\n                  top_logprobs: z.array(\n                    z.object({\n                      token: z.string(),\n                      logprob: z.number(),\n                    }),\n                  ),\n                }),\n              )\n              .nullable(),\n          })\n          .nullish(),\n        finish_reason: z.string().nullish(),\n        index: z.number(),\n      }),\n    ),\n    usage: openaiTokenUsageSchema,\n  }),\n  openaiErrorDataSchema,\n]);\n\nfunction isReasoningModel(modelId: string) {\n  return modelId.startsWith('o') || modelId.startsWith('gpt-5');\n}\n\nfunction isAudioModel(modelId: string) {\n  return modelId.startsWith('gpt-4o-audio-preview');\n}\n\nfunction getSystemMessageMode(modelId: string) {\n  if (!isReasoningModel(modelId)) {\n    return 'system';\n  }\n\n  return (\n    reasoningModels[modelId as keyof typeof reasoningModels]\n      ?.systemMessageMode ?? 'developer'\n  );\n}\n\nconst reasoningModels = {\n  'o1-mini': {\n    systemMessageMode: 'remove',\n  },\n  'o1-mini-2024-09-12': {\n    systemMessageMode: 'remove',\n  },\n  'o1-preview': {\n    systemMessageMode: 'remove',\n  },\n  'o1-preview-2024-09-12': {\n    systemMessageMode: 'remove',\n  },\n  o3: {\n    systemMessageMode: 'developer',\n  },\n  'o3-2025-04-16': {\n    systemMessageMode: 'developer',\n  },\n  'o3-mini': {\n    systemMessageMode: 'developer',\n  },\n  'o3-mini-2025-01-31': {\n    systemMessageMode: 'developer',\n  },\n  'o4-mini': {\n    systemMessageMode: 'developer',\n  },\n  'o4-mini-2025-04-16': {\n    systemMessageMode: 'developer',\n  },\n} as const;\n","import {\n  InvalidPromptError,\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport function convertToOpenAICompletionPrompt({\n  prompt,\n  inputFormat,\n  user = 'user',\n  assistant = 'assistant',\n}: {\n  prompt: LanguageModelV1Prompt;\n  inputFormat: 'prompt' | 'messages';\n  user?: string;\n  assistant?: string;\n}): {\n  prompt: string;\n  stopSequences?: string[];\n} {\n  // When the user supplied a prompt input, we don't transform it:\n  if (\n    inputFormat === 'prompt' &&\n    prompt.length === 1 &&\n    prompt[0].role === 'user' &&\n    prompt[0].content.length === 1 &&\n    prompt[0].content[0].type === 'text'\n  ) {\n    return { prompt: prompt[0].content[0].text };\n  }\n\n  // otherwise transform to a chat message format:\n  let text = '';\n\n  // if first message is a system message, add it to the text:\n  if (prompt[0].role === 'system') {\n    text += `${prompt[0].content}\\n\\n`;\n    prompt = prompt.slice(1);\n  }\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        throw new InvalidPromptError({\n          message: 'Unexpected system message in prompt: ${content}',\n          prompt,\n        });\n      }\n\n      case 'user': {\n        const userMessage = content\n          .map(part => {\n            switch (part.type) {\n              case 'text': {\n                return part.text;\n              }\n              case 'image': {\n                throw new UnsupportedFunctionalityError({\n                  functionality: 'images',\n                });\n              }\n            }\n          })\n          .join('');\n\n        text += `${user}:\\n${userMessage}\\n\\n`;\n        break;\n      }\n\n      case 'assistant': {\n        const assistantMessage = content\n          .map(part => {\n            switch (part.type) {\n              case 'text': {\n                return part.text;\n              }\n              case 'tool-call': {\n                throw new UnsupportedFunctionalityError({\n                  functionality: 'tool-call messages',\n                });\n              }\n            }\n          })\n          .join('');\n\n        text += `${assistant}:\\n${assistantMessage}\\n\\n`;\n        break;\n      }\n\n      case 'tool': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'tool messages',\n        });\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  // Assistant message prefix:\n  text += `${assistant}:\\n`;\n\n  return {\n    prompt: text,\n    stopSequences: [`\\n${user}:`],\n  };\n}\n","import { LanguageModelV1LogProbs } from '@ai-sdk/provider';\n\ntype OpenAICompletionLogProps = {\n  tokens: string[];\n  token_logprobs: number[];\n  top_logprobs: Record<string, number>[] | null;\n};\n\nexport function mapOpenAICompletionLogProbs(\n  logprobs: OpenAICompletionLogProps | null | undefined,\n): LanguageModelV1LogProbs | undefined {\n  return logprobs?.tokens.map((token, index) => ({\n    token,\n    logprob: logprobs.token_logprobs[index],\n    topLogprobs: logprobs.top_logprobs\n      ? Object.entries(logprobs.top_logprobs[index]).map(\n          ([token, logprob]) => ({\n            token,\n            logprob,\n          }),\n        )\n      : [],\n  }));\n}\n","import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1LogProbs,\n  LanguageModelV1StreamPart,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { convertToOpenAICompletionPrompt } from './convert-to-openai-completion-prompt';\nimport { mapOpenAICompletionLogProbs } from './map-openai-completion-logprobs';\nimport { mapOpenAIFinishReason } from './map-openai-finish-reason';\nimport {\n  OpenAICompletionModelId,\n  OpenAICompletionSettings,\n} from './openai-completion-settings';\nimport {\n  openaiErrorDataSchema,\n  openaiFailedResponseHandler,\n} from './openai-error';\nimport { getResponseMetadata } from './get-response-metadata';\n\ntype OpenAICompletionConfig = {\n  provider: string;\n  compatibility: 'strict' | 'compatible';\n  headers: () => Record<string, string | undefined>;\n  url: (options: { modelId: string; path: string }) => string;\n  fetch?: FetchFunction;\n};\n\nexport class OpenAICompletionLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly defaultObjectGenerationMode = undefined;\n\n  readonly modelId: OpenAICompletionModelId;\n  readonly settings: OpenAICompletionSettings;\n\n  private readonly config: OpenAICompletionConfig;\n\n  constructor(\n    modelId: OpenAICompletionModelId,\n    settings: OpenAICompletionSettings,\n    config: OpenAICompletionConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private getArgs({\n    mode,\n    inputFormat,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences: userStopSequences,\n    responseFormat,\n    seed,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const type = mode.type;\n\n    const warnings: LanguageModelV1CallWarning[] = [];\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (responseFormat != null && responseFormat.type !== 'text') {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details: 'JSON response format is not supported.',\n      });\n    }\n\n    const { prompt: completionPrompt, stopSequences } =\n      convertToOpenAICompletionPrompt({ prompt, inputFormat });\n\n    const stop = [...(stopSequences ?? []), ...(userStopSequences ?? [])];\n\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n\n      // model specific settings:\n      echo: this.settings.echo,\n      logit_bias: this.settings.logitBias,\n      logprobs:\n        typeof this.settings.logprobs === 'number'\n          ? this.settings.logprobs\n          : typeof this.settings.logprobs === 'boolean'\n            ? this.settings.logprobs\n              ? 0\n              : undefined\n            : undefined,\n      suffix: this.settings.suffix,\n      user: this.settings.user,\n\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n\n      // prompt:\n      prompt: completionPrompt,\n\n      // stop sequences:\n      stop: stop.length > 0 ? stop : undefined,\n    };\n\n    switch (type) {\n      case 'regular': {\n        if (mode.tools?.length) {\n          throw new UnsupportedFunctionalityError({\n            functionality: 'tools',\n          });\n        }\n\n        if (mode.toolChoice) {\n          throw new UnsupportedFunctionalityError({\n            functionality: 'toolChoice',\n          });\n        }\n\n        return { args: baseArgs, warnings };\n      }\n\n      case 'object-json': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'object-json mode',\n        });\n      }\n\n      case 'object-tool': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'object-tool mode',\n        });\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args, warnings } = this.getArgs(options);\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: '/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiCompletionResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { prompt: rawPrompt, ...rawSettings } = args;\n    const choice = response.choices[0];\n\n    return {\n      text: choice.text,\n      usage: {\n        promptTokens: response.usage.prompt_tokens,\n        completionTokens: response.usage.completion_tokens,\n      },\n      finishReason: mapOpenAIFinishReason(choice.finish_reason),\n      logprobs: mapOpenAICompletionLogProbs(choice.logprobs),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      response: getResponseMetadata(response),\n      warnings,\n      request: { body: JSON.stringify(args) },\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const { args, warnings } = this.getArgs(options);\n\n    const body = {\n      ...args,\n      stream: true,\n\n      // only include stream_options when in strict compatibility mode:\n      stream_options:\n        this.config.compatibility === 'strict'\n          ? { include_usage: true }\n          : undefined,\n    };\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        openaiCompletionChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { prompt: rawPrompt, ...rawSettings } = args;\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let usage: { promptTokens: number; completionTokens: number } = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN,\n    };\n    let logprobs: LanguageModelV1LogProbs;\n    let isFirstChunk = true;\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof openaiCompletionChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            // handle error chunks:\n            if ('error' in value) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: value.error });\n              return;\n            }\n\n            if (isFirstChunk) {\n              isFirstChunk = false;\n\n              controller.enqueue({\n                type: 'response-metadata',\n                ...getResponseMetadata(value),\n              });\n            }\n\n            if (value.usage != null) {\n              usage = {\n                promptTokens: value.usage.prompt_tokens,\n                completionTokens: value.usage.completion_tokens,\n              };\n            }\n\n            const choice = value.choices[0];\n\n            if (choice?.finish_reason != null) {\n              finishReason = mapOpenAIFinishReason(choice.finish_reason);\n            }\n\n            if (choice?.text != null) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: choice.text,\n              });\n            }\n\n            const mappedLogprobs = mapOpenAICompletionLogProbs(\n              choice?.logprobs,\n            );\n            if (mappedLogprobs?.length) {\n              if (logprobs === undefined) logprobs = [];\n              logprobs.push(...mappedLogprobs);\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              logprobs,\n              usage,\n            });\n          },\n        }),\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      request: { body: JSON.stringify(body) },\n    };\n  }\n}\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiCompletionResponseSchema = z.object({\n  id: z.string().nullish(),\n  created: z.number().nullish(),\n  model: z.string().nullish(),\n  choices: z.array(\n    z.object({\n      text: z.string(),\n      finish_reason: z.string(),\n      logprobs: z\n        .object({\n          tokens: z.array(z.string()),\n          token_logprobs: z.array(z.number()),\n          top_logprobs: z.array(z.record(z.string(), z.number())).nullable(),\n        })\n        .nullish(),\n    }),\n  ),\n  usage: z.object({\n    prompt_tokens: z.number(),\n    completion_tokens: z.number(),\n  }),\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiCompletionChunkSchema = z.union([\n  z.object({\n    id: z.string().nullish(),\n    created: z.number().nullish(),\n    model: z.string().nullish(),\n    choices: z.array(\n      z.object({\n        text: z.string(),\n        finish_reason: z.string().nullish(),\n        index: z.number(),\n        logprobs: z\n          .object({\n            tokens: z.array(z.string()),\n            token_logprobs: z.array(z.number()),\n            top_logprobs: z.array(z.record(z.string(), z.number())).nullable(),\n          })\n          .nullish(),\n      }),\n    ),\n    usage: z\n      .object({\n        prompt_tokens: z.number(),\n        completion_tokens: z.number(),\n      })\n      .nullish(),\n  }),\n  openaiErrorDataSchema,\n]);\n","import {\n  EmbeddingModelV1,\n  TooManyEmbeddingValuesForCallError,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport {\n  OpenAIEmbeddingModelId,\n  OpenAIEmbeddingSettings,\n} from './openai-embedding-settings';\nimport { openaiFailedResponseHandler } from './openai-error';\n\nexport class OpenAIEmbeddingModel implements EmbeddingModelV1<string> {\n  readonly specificationVersion = 'v1';\n  readonly modelId: OpenAIEmbeddingModelId;\n\n  private readonly config: OpenAIConfig;\n  private readonly settings: OpenAIEmbeddingSettings;\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  get maxEmbeddingsPerCall(): number {\n    return this.settings.maxEmbeddingsPerCall ?? 2048;\n  }\n\n  get supportsParallelCalls(): boolean {\n    return this.settings.supportsParallelCalls ?? true;\n  }\n\n  constructor(\n    modelId: OpenAIEmbeddingModelId,\n    settings: OpenAIEmbeddingSettings,\n    config: OpenAIConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  async doEmbed({\n    values,\n    headers,\n    abortSignal,\n  }: Parameters<EmbeddingModelV1<string>['doEmbed']>[0]): Promise<\n    Awaited<ReturnType<EmbeddingModelV1<string>['doEmbed']>>\n  > {\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values,\n      });\n    }\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/embeddings',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        input: values,\n        encoding_format: 'float',\n        dimensions: this.settings.dimensions,\n        user: this.settings.user,\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiTextEmbeddingResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      embeddings: response.data.map(item => item.embedding),\n      usage: response.usage\n        ? { tokens: response.usage.prompt_tokens }\n        : undefined,\n      rawResponse: { headers: responseHeaders },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiTextEmbeddingResponseSchema = z.object({\n  data: z.array(z.object({ embedding: z.array(z.number()) })),\n  usage: z.object({ prompt_tokens: z.number() }).nullish(),\n});\n","export type OpenAIImageModelId =\n  | 'gpt-image-1'\n  | 'dall-e-3'\n  | 'dall-e-2'\n  | (string & {});\n\n// https://platform.openai.com/docs/guides/images\nexport const modelMaxImagesPerCall: Record<OpenAIImageModelId, number> = {\n  'dall-e-3': 1,\n  'dall-e-2': 10,\n  'gpt-image-1': 10,\n};\n\nexport const hasDefaultResponseFormat = new Set(['gpt-image-1']);\n\nexport interface OpenAIImageSettings {\n  /**\nOverride the maximum number of images per call (default is dependent on the\nmodel, or 1 for an unknown model).\n   */\n  maxImagesPerCall?: number;\n}\n","import { ImageModelV1, ImageModelV1CallWarning } from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport { openaiFailedResponseHandler } from './openai-error';\nimport {\n  OpenAIImageModelId,\n  OpenAIImageSettings,\n  modelMaxImagesPerCall,\n  hasDefaultResponseFormat,\n} from './openai-image-settings';\n\ninterface OpenAIImageModelConfig extends OpenAIConfig {\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}\n\nexport class OpenAIImageModel implements ImageModelV1 {\n  readonly specificationVersion = 'v1';\n\n  get maxImagesPerCall(): number {\n    return (\n      this.settings.maxImagesPerCall ?? modelMaxImagesPerCall[this.modelId] ?? 1\n    );\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  constructor(\n    readonly modelId: OpenAIImageModelId,\n    private readonly settings: OpenAIImageSettings,\n    private readonly config: OpenAIImageModelConfig,\n  ) {}\n\n  async doGenerate({\n    prompt,\n    n,\n    size,\n    aspectRatio,\n    seed,\n    providerOptions,\n    headers,\n    abortSignal,\n  }: Parameters<ImageModelV1['doGenerate']>[0]): Promise<\n    Awaited<ReturnType<ImageModelV1['doGenerate']>>\n  > {\n    const warnings: Array<ImageModelV1CallWarning> = [];\n\n    if (aspectRatio != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'aspectRatio',\n        details:\n          'This model does not support aspect ratio. Use `size` instead.',\n      });\n    }\n\n    if (seed != null) {\n      warnings.push({ type: 'unsupported-setting', setting: 'seed' });\n    }\n\n    const currentDate = this.config._internal?.currentDate?.() ?? new Date();\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: '/images/generations',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        prompt,\n        n,\n        size,\n        ...(providerOptions.openai ?? {}),\n        ...(!hasDefaultResponseFormat.has(this.modelId)\n          ? { response_format: 'b64_json' }\n          : {}),\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiImageResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      images: response.data.map(item => item.b64_json),\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n      },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiImageResponseSchema = z.object({\n  data: z.array(z.object({ b64_json: z.string() })),\n});\n","import {\n  TranscriptionModelV1,\n  TranscriptionModelV1CallOptions,\n  TranscriptionModelV1CallWarning,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  convertBase64ToUint8Array,\n  createJsonResponseHandler,\n  parseProviderOptions,\n  postFormDataToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport { openaiFailedResponseHandler } from './openai-error';\nimport {\n  OpenAITranscriptionModelId,\n  OpenAITranscriptionModelOptions,\n} from './openai-transcription-settings';\n\n// https://platform.openai.com/docs/api-reference/audio/createTranscription\nconst openAIProviderOptionsSchema = z.object({\n  include: z.array(z.string()).nullish(),\n  language: z.string().nullish(),\n  prompt: z.string().nullish(),\n  temperature: z.number().min(0).max(1).nullish().default(0),\n  timestampGranularities: z\n    .array(z.enum(['word', 'segment']))\n    .nullish()\n    .default(['segment']),\n});\n\nexport type OpenAITranscriptionCallOptions = Omit<\n  TranscriptionModelV1CallOptions,\n  'providerOptions'\n> & {\n  providerOptions?: {\n    openai?: z.infer<typeof openAIProviderOptionsSchema>;\n  };\n};\n\ninterface OpenAITranscriptionModelConfig extends OpenAIConfig {\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}\n\n// https://platform.openai.com/docs/guides/speech-to-text#supported-languages\nconst languageMap = {\n  afrikaans: 'af',\n  arabic: 'ar',\n  armenian: 'hy',\n  azerbaijani: 'az',\n  belarusian: 'be',\n  bosnian: 'bs',\n  bulgarian: 'bg',\n  catalan: 'ca',\n  chinese: 'zh',\n  croatian: 'hr',\n  czech: 'cs',\n  danish: 'da',\n  dutch: 'nl',\n  english: 'en',\n  estonian: 'et',\n  finnish: 'fi',\n  french: 'fr',\n  galician: 'gl',\n  german: 'de',\n  greek: 'el',\n  hebrew: 'he',\n  hindi: 'hi',\n  hungarian: 'hu',\n  icelandic: 'is',\n  indonesian: 'id',\n  italian: 'it',\n  japanese: 'ja',\n  kannada: 'kn',\n  kazakh: 'kk',\n  korean: 'ko',\n  latvian: 'lv',\n  lithuanian: 'lt',\n  macedonian: 'mk',\n  malay: 'ms',\n  marathi: 'mr',\n  maori: 'mi',\n  nepali: 'ne',\n  norwegian: 'no',\n  persian: 'fa',\n  polish: 'pl',\n  portuguese: 'pt',\n  romanian: 'ro',\n  russian: 'ru',\n  serbian: 'sr',\n  slovak: 'sk',\n  slovenian: 'sl',\n  spanish: 'es',\n  swahili: 'sw',\n  swedish: 'sv',\n  tagalog: 'tl',\n  tamil: 'ta',\n  thai: 'th',\n  turkish: 'tr',\n  ukrainian: 'uk',\n  urdu: 'ur',\n  vietnamese: 'vi',\n  welsh: 'cy',\n};\n\nexport class OpenAITranscriptionModel implements TranscriptionModelV1 {\n  readonly specificationVersion = 'v1';\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  constructor(\n    readonly modelId: OpenAITranscriptionModelId,\n    private readonly config: OpenAITranscriptionModelConfig,\n  ) {}\n\n  private getArgs({\n    audio,\n    mediaType,\n    providerOptions,\n  }: OpenAITranscriptionCallOptions) {\n    const warnings: TranscriptionModelV1CallWarning[] = [];\n\n    // Parse provider options\n    const openAIOptions = parseProviderOptions({\n      provider: 'openai',\n      providerOptions,\n      schema: openAIProviderOptionsSchema,\n    });\n\n    // Create form data with base fields\n    const formData = new FormData();\n    const blob =\n      audio instanceof Uint8Array\n        ? new Blob([audio])\n        : new Blob([convertBase64ToUint8Array(audio)]);\n\n    formData.append('model', this.modelId);\n    formData.append('file', new File([blob], 'audio', { type: mediaType }));\n\n    // Add provider-specific options\n    if (openAIOptions) {\n      const transcriptionModelOptions: OpenAITranscriptionModelOptions = {\n        include: openAIOptions.include ?? undefined,\n        language: openAIOptions.language ?? undefined,\n        prompt: openAIOptions.prompt ?? undefined,\n        temperature: openAIOptions.temperature ?? undefined,\n        timestamp_granularities:\n          openAIOptions.timestampGranularities ?? undefined,\n      };\n\n      for (const key in transcriptionModelOptions) {\n        const value =\n          transcriptionModelOptions[\n            key as keyof OpenAITranscriptionModelOptions\n          ];\n        if (value !== undefined) {\n          formData.append(key, String(value));\n        }\n      }\n    }\n\n    return {\n      formData,\n      warnings,\n    };\n  }\n\n  async doGenerate(\n    options: OpenAITranscriptionCallOptions,\n  ): Promise<Awaited<ReturnType<TranscriptionModelV1['doGenerate']>>> {\n    const currentDate = this.config._internal?.currentDate?.() ?? new Date();\n    const { formData, warnings } = this.getArgs(options);\n\n    const {\n      value: response,\n      responseHeaders,\n      rawValue: rawResponse,\n    } = await postFormDataToApi({\n      url: this.config.url({\n        path: '/audio/transcriptions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      formData,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiTranscriptionResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const language =\n      response.language != null && response.language in languageMap\n        ? languageMap[response.language as keyof typeof languageMap]\n        : undefined;\n\n    return {\n      text: response.text,\n      segments:\n        response.words?.map(word => ({\n          text: word.word,\n          startSecond: word.start,\n          endSecond: word.end,\n        })) ?? [],\n      language,\n      durationInSeconds: response.duration ?? undefined,\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n        body: rawResponse,\n      },\n    };\n  }\n}\n\nconst openaiTranscriptionResponseSchema = z.object({\n  text: z.string(),\n  language: z.string().nullish(),\n  duration: z.number().nullish(),\n  words: z\n    .array(\n      z.object({\n        word: z.string(),\n        start: z.number(),\n        end: z.number(),\n      }),\n    )\n    .nullish(),\n});\n","import {\n  LanguageModelV1CallWarning,\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport { OpenAIResponsesPrompt } from './openai-responses-api-types';\n\nexport function convertToOpenAIResponsesMessages({\n  prompt,\n  systemMessageMode,\n}: {\n  prompt: LanguageModelV1Prompt;\n  systemMessageMode: 'system' | 'developer' | 'remove';\n}): {\n  messages: OpenAIResponsesPrompt;\n  warnings: Array<LanguageModelV1CallWarning>;\n} {\n  const messages: OpenAIResponsesPrompt = [];\n  const warnings: Array<LanguageModelV1CallWarning> = [];\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        switch (systemMessageMode) {\n          case 'system': {\n            messages.push({ role: 'system', content });\n            break;\n          }\n          case 'developer': {\n            messages.push({ role: 'developer', content });\n            break;\n          }\n          case 'remove': {\n            warnings.push({\n              type: 'other',\n              message: 'system messages are removed for this model',\n            });\n            break;\n          }\n          default: {\n            const _exhaustiveCheck: never = systemMessageMode;\n            throw new Error(\n              `Unsupported system message mode: ${_exhaustiveCheck}`,\n            );\n          }\n        }\n        break;\n      }\n\n      case 'user': {\n        messages.push({\n          role: 'user',\n          content: content.map((part, index) => {\n            switch (part.type) {\n              case 'text': {\n                return { type: 'input_text', text: part.text };\n              }\n              case 'image': {\n                return {\n                  type: 'input_image',\n                  image_url:\n                    part.image instanceof URL\n                      ? part.image.toString()\n                      : `data:${\n                          part.mimeType ?? 'image/jpeg'\n                        };base64,${convertUint8ArrayToBase64(part.image)}`,\n\n                  // OpenAI specific extension: image detail\n                  detail: part.providerMetadata?.openai?.imageDetail,\n                };\n              }\n              case 'file': {\n                if (part.data instanceof URL) {\n                  // The AI SDK automatically downloads files for user file parts with URLs\n                  throw new UnsupportedFunctionalityError({\n                    functionality: 'File URLs in user messages',\n                  });\n                }\n\n                switch (part.mimeType) {\n                  case 'application/pdf': {\n                    return {\n                      type: 'input_file',\n                      filename: part.filename ?? `part-${index}.pdf`,\n                      file_data: `data:application/pdf;base64,${part.data}`,\n                    };\n                  }\n                  default: {\n                    throw new UnsupportedFunctionalityError({\n                      functionality:\n                        'Only PDF files are supported in user messages',\n                    });\n                  }\n                }\n              }\n            }\n          }),\n        });\n\n        break;\n      }\n\n      case 'assistant': {\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              messages.push({\n                role: 'assistant',\n                content: [{ type: 'output_text', text: part.text }],\n              });\n              break;\n            }\n            case 'tool-call': {\n              messages.push({\n                type: 'function_call',\n                call_id: part.toolCallId,\n                name: part.toolName,\n                arguments: JSON.stringify(part.args),\n              });\n              break;\n            }\n          }\n        }\n\n        break;\n      }\n\n      case 'tool': {\n        for (const part of content) {\n          messages.push({\n            type: 'function_call_output',\n            call_id: part.toolCallId,\n            output: JSON.stringify(part.result),\n          });\n        }\n\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return { messages, warnings };\n}\n","import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\nexport function mapOpenAIResponseFinishReason({\n  finishReason,\n  hasToolCalls,\n}: {\n  finishReason: string | null | undefined;\n  hasToolCalls: boolean;\n}): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case undefined:\n    case null:\n      return hasToolCalls ? 'tool-calls' : 'stop';\n    case 'max_output_tokens':\n      return 'length';\n    case 'content_filter':\n      return 'content-filter';\n    default:\n      return hasToolCalls ? 'tool-calls' : 'unknown';\n  }\n}\n","import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { OpenAIResponsesTool } from './openai-responses-api-types';\n\nexport function prepareResponsesTools({\n  mode,\n  strict,\n}: {\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  };\n  strict: boolean;\n}): {\n  tools?: Array<OpenAIResponsesTool>;\n  tool_choice?:\n    | 'auto'\n    | 'none'\n    | 'required'\n    | { type: 'web_search_preview' }\n    | { type: 'function'; name: string };\n  toolWarnings: LanguageModelV1CallWarning[];\n} {\n  // when the tools array is empty, change it to undefined to prevent errors:\n  const tools = mode.tools?.length ? mode.tools : undefined;\n\n  const toolWarnings: LanguageModelV1CallWarning[] = [];\n\n  if (tools == null) {\n    return { tools: undefined, tool_choice: undefined, toolWarnings };\n  }\n\n  const toolChoice = mode.toolChoice;\n\n  const openaiTools: Array<OpenAIResponsesTool> = [];\n\n  for (const tool of tools) {\n    switch (tool.type) {\n      case 'function':\n        openaiTools.push({\n          type: 'function',\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n          strict: strict ? true : undefined,\n        });\n        break;\n      case 'provider-defined':\n        switch (tool.id) {\n          case 'openai.web_search_preview':\n            openaiTools.push({\n              type: 'web_search_preview',\n              search_context_size: tool.args.searchContextSize as\n                | 'low'\n                | 'medium'\n                | 'high',\n              user_location: tool.args.userLocation as {\n                type: 'approximate';\n                city: string;\n                region: string;\n              },\n            });\n            break;\n          default:\n            toolWarnings.push({ type: 'unsupported-tool', tool });\n            break;\n        }\n        break;\n      default:\n        toolWarnings.push({ type: 'unsupported-tool', tool });\n        break;\n    }\n  }\n\n  if (toolChoice == null) {\n    return { tools: openaiTools, tool_choice: undefined, toolWarnings };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n    case 'none':\n    case 'required':\n      return { tools: openaiTools, tool_choice: type, toolWarnings };\n    case 'tool': {\n      if (toolChoice.toolName === 'web_search_preview') {\n        return {\n          tools: openaiTools,\n          tool_choice: {\n            type: 'web_search_preview',\n          },\n          toolWarnings,\n        };\n      }\n      return {\n        tools: openaiTools,\n        tool_choice: {\n          type: 'function',\n          name: toolChoice.toolName,\n        },\n        toolWarnings,\n      };\n    }\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n","import {\n  APICallError,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1StreamPart,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  generateId,\n  parseProviderOptions,\n  ParseResult,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from '../openai-config';\nimport { openaiFailedResponseHandler } from '../openai-error';\nimport { convertToOpenAIResponsesMessages } from './convert-to-openai-responses-messages';\nimport { mapOpenAIResponseFinishReason } from './map-openai-responses-finish-reason';\nimport { prepareResponsesTools } from './openai-responses-prepare-tools';\nimport { OpenAIResponsesModelId } from './openai-responses-settings';\n\nexport class OpenAIResponsesLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly defaultObjectGenerationMode = 'json';\n  readonly supportsStructuredOutputs = true;\n\n  readonly modelId: OpenAIResponsesModelId;\n\n  private readonly config: OpenAIConfig;\n\n  constructor(modelId: OpenAIResponsesModelId, config: OpenAIConfig) {\n    this.modelId = modelId;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private getArgs({\n    mode,\n    maxTokens,\n    temperature,\n    stopSequences,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    seed,\n    prompt,\n    providerMetadata,\n    responseFormat,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const warnings: LanguageModelV1CallWarning[] = [];\n    const modelConfig = getResponsesModelConfig(this.modelId);\n    const type = mode.type;\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (seed != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'seed',\n      });\n    }\n\n    if (presencePenalty != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'presencePenalty',\n      });\n    }\n\n    if (frequencyPenalty != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'frequencyPenalty',\n      });\n    }\n\n    if (stopSequences != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'stopSequences',\n      });\n    }\n\n    const { messages, warnings: messageWarnings } =\n      convertToOpenAIResponsesMessages({\n        prompt,\n        systemMessageMode: modelConfig.systemMessageMode,\n      });\n\n    warnings.push(...messageWarnings);\n\n    const openaiOptions = parseProviderOptions({\n      provider: 'openai',\n      providerOptions: providerMetadata,\n      schema: openaiResponsesProviderOptionsSchema,\n    });\n\n    const isStrict = openaiOptions?.strictSchemas ?? true;\n\n    const baseArgs = {\n      model: this.modelId,\n      input: messages,\n      temperature,\n      top_p: topP,\n      max_output_tokens: maxTokens,\n\n      ...(responseFormat?.type === 'json' && {\n        text: {\n          format:\n            responseFormat.schema != null\n              ? {\n                  type: 'json_schema',\n                  strict: isStrict,\n                  name: responseFormat.name ?? 'response',\n                  description: responseFormat.description,\n                  schema: responseFormat.schema,\n                }\n              : { type: 'json_object' },\n        },\n      }),\n\n      // provider options:\n      metadata: openaiOptions?.metadata,\n      parallel_tool_calls: openaiOptions?.parallelToolCalls,\n      previous_response_id: openaiOptions?.previousResponseId,\n      store: openaiOptions?.store,\n      user: openaiOptions?.user,\n      instructions: openaiOptions?.instructions,\n\n      // model-specific settings:\n      ...(modelConfig.isReasoningModel &&\n        (openaiOptions?.reasoningEffort != null ||\n          openaiOptions?.reasoningSummary != null) && {\n          reasoning: {\n            ...(openaiOptions?.reasoningEffort != null && {\n              effort: openaiOptions.reasoningEffort,\n            }),\n            ...(openaiOptions?.reasoningSummary != null && {\n              summary: openaiOptions.reasoningSummary,\n            }),\n          },\n        }),\n      ...(modelConfig.requiredAutoTruncation && {\n        truncation: 'auto',\n      }),\n    };\n\n    if (modelConfig.isReasoningModel) {\n      // remove unsupported settings for reasoning models\n      // see https://platform.openai.com/docs/guides/reasoning#limitations\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'temperature',\n          details: 'temperature is not supported for reasoning models',\n        });\n      }\n\n      if (baseArgs.top_p != null) {\n        baseArgs.top_p = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'topP',\n          details: 'topP is not supported for reasoning models',\n        });\n      }\n    }\n\n    switch (type) {\n      case 'regular': {\n        const { tools, tool_choice, toolWarnings } = prepareResponsesTools({\n          mode,\n          strict: isStrict, // TODO support provider options on tools\n        });\n\n        return {\n          args: {\n            ...baseArgs,\n            tools,\n            tool_choice,\n          },\n          warnings: [...warnings, ...toolWarnings],\n        };\n      }\n\n      case 'object-json': {\n        return {\n          args: {\n            ...baseArgs,\n            text: {\n              format:\n                mode.schema != null\n                  ? {\n                      type: 'json_schema',\n                      strict: isStrict,\n                      name: mode.name ?? 'response',\n                      description: mode.description,\n                      schema: mode.schema,\n                    }\n                  : { type: 'json_object' },\n            },\n          },\n          warnings,\n        };\n      }\n\n      case 'object-tool': {\n        return {\n          args: {\n            ...baseArgs,\n            tool_choice: { type: 'function', name: mode.tool.name },\n            tools: [\n              {\n                type: 'function',\n                name: mode.tool.name,\n                description: mode.tool.description,\n                parameters: mode.tool.parameters,\n                strict: isStrict,\n              },\n            ],\n          },\n          warnings,\n        };\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args: body, warnings } = this.getArgs(options);\n    const url = this.config.url({\n      path: '/responses',\n      modelId: this.modelId,\n    });\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url,\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        z.object({\n          id: z.string(),\n          created_at: z.number(),\n          error: z\n            .object({\n              message: z.string(),\n              code: z.string(),\n            })\n            .nullish(),\n          model: z.string(),\n          output: z.array(\n            z.discriminatedUnion('type', [\n              z.object({\n                type: z.literal('message'),\n                role: z.literal('assistant'),\n                content: z.array(\n                  z.object({\n                    type: z.literal('output_text'),\n                    text: z.string(),\n                    annotations: z.array(\n                      z.object({\n                        type: z.literal('url_citation'),\n                        start_index: z.number(),\n                        end_index: z.number(),\n                        url: z.string(),\n                        title: z.string(),\n                      }),\n                    ),\n                  }),\n                ),\n              }),\n              z.object({\n                type: z.literal('function_call'),\n                call_id: z.string(),\n                name: z.string(),\n                arguments: z.string(),\n              }),\n              z.object({\n                type: z.literal('web_search_call'),\n              }),\n              z.object({\n                type: z.literal('computer_call'),\n              }),\n              z.object({\n                type: z.literal('reasoning'),\n                summary: z.array(\n                  z.object({\n                    type: z.literal('summary_text'),\n                    text: z.string(),\n                  }),\n                ),\n              }),\n            ]),\n          ),\n          incomplete_details: z.object({ reason: z.string() }).nullable(),\n          usage: usageSchema,\n        }),\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    if (response.error) {\n      throw new APICallError({\n        message: response.error.message,\n        url,\n        requestBodyValues: body,\n        statusCode: 400,\n        responseHeaders,\n        responseBody: rawResponse as string,\n        isRetryable: false,\n      });\n    }\n\n    const outputTextElements = response.output\n      .filter(output => output.type === 'message')\n      .flatMap(output => output.content)\n      .filter(content => content.type === 'output_text');\n\n    const toolCalls = response.output\n      .filter(output => output.type === 'function_call')\n      .map(output => ({\n        toolCallType: 'function' as const,\n        toolCallId: output.call_id,\n        toolName: output.name,\n        args: output.arguments,\n      }));\n\n    const reasoningSummary =\n      response.output.find(item => item.type === 'reasoning')?.summary ?? null;\n\n    return {\n      text: outputTextElements.map(content => content.text).join('\\n'),\n      sources: outputTextElements.flatMap(content =>\n        content.annotations.map(annotation => ({\n          sourceType: 'url',\n          id: this.config.generateId?.() ?? generateId(),\n          url: annotation.url,\n          title: annotation.title,\n        })),\n      ),\n      finishReason: mapOpenAIResponseFinishReason({\n        finishReason: response.incomplete_details?.reason,\n        hasToolCalls: toolCalls.length > 0,\n      }),\n      toolCalls: toolCalls.length > 0 ? toolCalls : undefined,\n      reasoning: reasoningSummary\n        ? reasoningSummary.map(summary => ({\n            type: 'text' as const,\n            text: summary.text,\n          }))\n        : undefined,\n      usage: {\n        promptTokens: response.usage.input_tokens,\n        completionTokens: response.usage.output_tokens,\n      },\n      rawCall: {\n        rawPrompt: undefined,\n        rawSettings: {},\n      },\n      rawResponse: {\n        headers: responseHeaders,\n        body: rawResponse,\n      },\n      request: {\n        body: JSON.stringify(body),\n      },\n      response: {\n        id: response.id,\n        timestamp: new Date(response.created_at * 1000),\n        modelId: response.model,\n      },\n      providerMetadata: {\n        openai: {\n          responseId: response.id,\n          cachedPromptTokens:\n            response.usage.input_tokens_details?.cached_tokens ?? null,\n          reasoningTokens:\n            response.usage.output_tokens_details?.reasoning_tokens ?? null,\n        },\n      },\n      warnings,\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const { args: body, warnings } = this.getArgs(options);\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/responses',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: {\n        ...body,\n        stream: true,\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        openaiResponsesChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const self = this;\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let promptTokens = NaN;\n    let completionTokens = NaN;\n    let cachedPromptTokens: number | null = null;\n    let reasoningTokens: number | null = null;\n    let responseId: string | null = null;\n    const ongoingToolCalls: Record<\n      number,\n      { toolName: string; toolCallId: string } | undefined\n    > = {};\n    let hasToolCalls = false;\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof openaiResponsesChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            if (isResponseOutputItemAddedChunk(value)) {\n              if (value.item.type === 'function_call') {\n                ongoingToolCalls[value.output_index] = {\n                  toolName: value.item.name,\n                  toolCallId: value.item.call_id,\n                };\n\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallType: 'function',\n                  toolCallId: value.item.call_id,\n                  toolName: value.item.name,\n                  argsTextDelta: value.item.arguments,\n                });\n              }\n            } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {\n              const toolCall = ongoingToolCalls[value.output_index];\n\n              if (toolCall != null) {\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallType: 'function',\n                  toolCallId: toolCall.toolCallId,\n                  toolName: toolCall.toolName,\n                  argsTextDelta: value.delta,\n                });\n              }\n            } else if (isResponseCreatedChunk(value)) {\n              responseId = value.response.id;\n              controller.enqueue({\n                type: 'response-metadata',\n                id: value.response.id,\n                timestamp: new Date(value.response.created_at * 1000),\n                modelId: value.response.model,\n              });\n            } else if (isTextDeltaChunk(value)) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: value.delta,\n              });\n            } else if (isResponseReasoningSummaryTextDeltaChunk(value)) {\n              controller.enqueue({\n                type: 'reasoning',\n                textDelta: value.delta,\n              });\n            } else if (\n              isResponseOutputItemDoneChunk(value) &&\n              value.item.type === 'function_call'\n            ) {\n              ongoingToolCalls[value.output_index] = undefined;\n              hasToolCalls = true;\n              controller.enqueue({\n                type: 'tool-call',\n                toolCallType: 'function',\n                toolCallId: value.item.call_id,\n                toolName: value.item.name,\n                args: value.item.arguments,\n              });\n            } else if (isResponseFinishedChunk(value)) {\n              finishReason = mapOpenAIResponseFinishReason({\n                finishReason: value.response.incomplete_details?.reason,\n                hasToolCalls,\n              });\n              promptTokens = value.response.usage.input_tokens;\n              completionTokens = value.response.usage.output_tokens;\n              cachedPromptTokens =\n                value.response.usage.input_tokens_details?.cached_tokens ??\n                cachedPromptTokens;\n              reasoningTokens =\n                value.response.usage.output_tokens_details?.reasoning_tokens ??\n                reasoningTokens;\n            } else if (isResponseAnnotationAddedChunk(value)) {\n              controller.enqueue({\n                type: 'source',\n                source: {\n                  sourceType: 'url',\n                  id: self.config.generateId?.() ?? generateId(),\n                  url: value.annotation.url,\n                  title: value.annotation.title,\n                },\n              });\n            } else if (isErrorChunk(value)) {\n              controller.enqueue({ type: 'error', error: value });\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              usage: { promptTokens, completionTokens },\n              ...((cachedPromptTokens != null || reasoningTokens != null) && {\n                providerMetadata: {\n                  openai: {\n                    responseId,\n                    cachedPromptTokens,\n                    reasoningTokens,\n                  },\n                },\n              }),\n            });\n          },\n        }),\n      ),\n      rawCall: {\n        rawPrompt: undefined,\n        rawSettings: {},\n      },\n      rawResponse: { headers: responseHeaders },\n      request: { body: JSON.stringify(body) },\n      warnings,\n    };\n  }\n}\n\nconst usageSchema = z.object({\n  input_tokens: z.number(),\n  input_tokens_details: z\n    .object({ cached_tokens: z.number().nullish() })\n    .nullish(),\n  output_tokens: z.number(),\n  output_tokens_details: z\n    .object({ reasoning_tokens: z.number().nullish() })\n    .nullish(),\n});\n\nconst textDeltaChunkSchema = z.object({\n  type: z.literal('response.output_text.delta'),\n  delta: z.string(),\n});\n\nconst responseFinishedChunkSchema = z.object({\n  type: z.enum(['response.completed', 'response.incomplete']),\n  response: z.object({\n    incomplete_details: z.object({ reason: z.string() }).nullish(),\n    usage: usageSchema,\n  }),\n});\n\nconst responseCreatedChunkSchema = z.object({\n  type: z.literal('response.created'),\n  response: z.object({\n    id: z.string(),\n    created_at: z.number(),\n    model: z.string(),\n  }),\n});\n\nconst responseOutputItemDoneSchema = z.object({\n  type: z.literal('response.output_item.done'),\n  output_index: z.number(),\n  item: z.discriminatedUnion('type', [\n    z.object({\n      type: z.literal('message'),\n    }),\n    z.object({\n      type: z.literal('function_call'),\n      id: z.string(),\n      call_id: z.string(),\n      name: z.string(),\n      arguments: z.string(),\n      status: z.literal('completed'),\n    }),\n  ]),\n});\n\nconst responseFunctionCallArgumentsDeltaSchema = z.object({\n  type: z.literal('response.function_call_arguments.delta'),\n  item_id: z.string(),\n  output_index: z.number(),\n  delta: z.string(),\n});\n\nconst responseOutputItemAddedSchema = z.object({\n  type: z.literal('response.output_item.added'),\n  output_index: z.number(),\n  item: z.discriminatedUnion('type', [\n    z.object({\n      type: z.literal('message'),\n    }),\n    z.object({\n      type: z.literal('function_call'),\n      id: z.string(),\n      call_id: z.string(),\n      name: z.string(),\n      arguments: z.string(),\n    }),\n  ]),\n});\n\nconst responseAnnotationAddedSchema = z.object({\n  type: z.literal('response.output_text.annotation.added'),\n  annotation: z.object({\n    type: z.literal('url_citation'),\n    url: z.string(),\n    title: z.string(),\n  }),\n});\n\nconst responseReasoningSummaryTextDeltaSchema = z.object({\n  type: z.literal('response.reasoning_summary_text.delta'),\n  item_id: z.string(),\n  output_index: z.number(),\n  summary_index: z.number(),\n  delta: z.string(),\n});\n\nconst errorChunkSchema = z.object({\n  type: z.literal('error'),\n  code: z.string(),\n  message: z.string(),\n  param: z.string().nullish(),\n  sequence_number: z.number(),\n});\n\nconst openaiResponsesChunkSchema = z.union([\n  textDeltaChunkSchema,\n  responseFinishedChunkSchema,\n  responseCreatedChunkSchema,\n  responseOutputItemDoneSchema,\n  responseFunctionCallArgumentsDeltaSchema,\n  responseOutputItemAddedSchema,\n  responseAnnotationAddedSchema,\n  responseReasoningSummaryTextDeltaSchema,\n  errorChunkSchema,\n  z.object({ type: z.string() }).passthrough(), // fallback for unknown chunks\n]);\n\nfunction isTextDeltaChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof textDeltaChunkSchema> {\n  return chunk.type === 'response.output_text.delta';\n}\n\nfunction isResponseOutputItemDoneChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseOutputItemDoneSchema> {\n  return chunk.type === 'response.output_item.done';\n}\n\nfunction isResponseFinishedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseFinishedChunkSchema> {\n  return (\n    chunk.type === 'response.completed' || chunk.type === 'response.incomplete'\n  );\n}\n\nfunction isResponseCreatedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseCreatedChunkSchema> {\n  return chunk.type === 'response.created';\n}\n\nfunction isResponseFunctionCallArgumentsDeltaChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseFunctionCallArgumentsDeltaSchema> {\n  return chunk.type === 'response.function_call_arguments.delta';\n}\n\nfunction isResponseOutputItemAddedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseOutputItemAddedSchema> {\n  return chunk.type === 'response.output_item.added';\n}\n\nfunction isResponseAnnotationAddedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseAnnotationAddedSchema> {\n  return chunk.type === 'response.output_text.annotation.added';\n}\n\nfunction isResponseReasoningSummaryTextDeltaChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseReasoningSummaryTextDeltaSchema> {\n  return chunk.type === 'response.reasoning_summary_text.delta';\n}\n\nfunction isErrorChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof errorChunkSchema> {\n  return chunk.type === 'error';\n}\n\ntype ResponsesModelConfig = {\n  isReasoningModel: boolean;\n  systemMessageMode: 'remove' | 'system' | 'developer';\n  requiredAutoTruncation: boolean;\n};\n\nfunction getResponsesModelConfig(modelId: string): ResponsesModelConfig {\n  // o series reasoning models:\n  if (modelId.startsWith('o') || modelId.startsWith('gpt-5')) {\n    if (modelId.startsWith('o1-mini') || modelId.startsWith('o1-preview')) {\n      return {\n        isReasoningModel: true,\n        systemMessageMode: 'remove',\n        requiredAutoTruncation: false,\n      };\n    }\n\n    return {\n      isReasoningModel: true,\n      systemMessageMode: 'developer',\n      requiredAutoTruncation: false,\n    };\n  }\n\n  // gpt models:\n  return {\n    isReasoningModel: false,\n    systemMessageMode: 'system',\n    requiredAutoTruncation: false,\n  };\n}\n\nconst openaiResponsesProviderOptionsSchema = z.object({\n  metadata: z.any().nullish(),\n  parallelToolCalls: z.boolean().nullish(),\n  previousResponseId: z.string().nullish(),\n  store: z.boolean().nullish(),\n  user: z.string().nullish(),\n  reasoningEffort: z.string().nullish(),\n  strictSchemas: z.boolean().nullish(),\n  instructions: z.string().nullish(),\n  reasoningSummary: z.string().nullish(),\n});\n\nexport type OpenAIResponsesProviderOptions = z.infer<\n  typeof openaiResponsesProviderOptionsSchema\n>;\n","import { z } from 'zod';\n\nconst WebSearchPreviewParameters = z.object({});\n\nfunction webSearchPreviewTool({\n  searchContextSize,\n  userLocation,\n}: {\n  searchContextSize?: 'low' | 'medium' | 'high';\n  userLocation?: {\n    type?: 'approximate';\n    city?: string;\n    region?: string;\n    country?: string;\n    timezone?: string;\n  };\n} = {}): {\n  type: 'provider-defined';\n  id: 'openai.web_search_preview';\n  args: {};\n  parameters: typeof WebSearchPreviewParameters;\n} {\n  return {\n    type: 'provider-defined',\n    id: 'openai.web_search_preview',\n    args: {\n      searchContextSize,\n      userLocation,\n    },\n    parameters: WebSearchPreviewParameters,\n  };\n}\n\nexport const openaiTools = {\n  webSearchPreview: webSearchPreviewTool,\n};\n","import { SpeechModelV1, SpeechModelV1CallWarning } from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createBinaryResponseHandler,\n  parseProviderOptions,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport { openaiFailedResponseHandler } from './openai-error';\nimport { OpenAISpeechModelId } from './openai-speech-settings';\nimport { OpenAISpeechAPITypes } from './openai-api-types';\n\n// https://platform.openai.com/docs/api-reference/audio/createSpeech\nconst OpenAIProviderOptionsSchema = z.object({\n  instructions: z.string().nullish(),\n  speed: z.number().min(0.25).max(4.0).default(1.0).nullish(),\n});\n\nexport type OpenAISpeechCallOptions = z.infer<\n  typeof OpenAIProviderOptionsSchema\n>;\n\ninterface OpenAISpeechModelConfig extends OpenAIConfig {\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}\n\nexport class OpenAISpeechModel implements SpeechModelV1 {\n  readonly specificationVersion = 'v1';\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  constructor(\n    readonly modelId: OpenAISpeechModelId,\n    private readonly config: OpenAISpeechModelConfig,\n  ) {}\n\n  private getArgs({\n    text,\n    voice = 'alloy',\n    outputFormat = 'mp3',\n    speed,\n    instructions,\n    providerOptions,\n  }: Parameters<SpeechModelV1['doGenerate']>[0]) {\n    const warnings: SpeechModelV1CallWarning[] = [];\n\n    // Parse provider options\n    const openAIOptions = parseProviderOptions({\n      provider: 'openai',\n      providerOptions,\n      schema: OpenAIProviderOptionsSchema,\n    });\n\n    // Create request body\n    const requestBody: Record<string, unknown> = {\n      model: this.modelId,\n      input: text,\n      voice,\n      response_format: 'mp3',\n      speed,\n      instructions,\n    };\n\n    if (outputFormat) {\n      if (['mp3', 'opus', 'aac', 'flac', 'wav', 'pcm'].includes(outputFormat)) {\n        requestBody.response_format = outputFormat;\n      } else {\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'outputFormat',\n          details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`,\n        });\n      }\n    }\n\n    // Add provider-specific options\n    if (openAIOptions) {\n      const speechModelOptions: OpenAISpeechAPITypes = {};\n\n      for (const key in speechModelOptions) {\n        const value = speechModelOptions[key as keyof OpenAISpeechAPITypes];\n        if (value !== undefined) {\n          requestBody[key] = value;\n        }\n      }\n    }\n\n    return {\n      requestBody,\n      warnings,\n    };\n  }\n\n  async doGenerate(\n    options: Parameters<SpeechModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<SpeechModelV1['doGenerate']>>> {\n    const currentDate = this.config._internal?.currentDate?.() ?? new Date();\n    const { requestBody, warnings } = this.getArgs(options);\n\n    const {\n      value: audio,\n      responseHeaders,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: '/audio/speech',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: requestBody,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createBinaryResponseHandler(),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      audio,\n      warnings,\n      request: {\n        body: JSON.stringify(requestBody),\n      },\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n        body: rawResponse,\n      },\n    };\n  }\n}\n","import {\n  EmbeddingModelV1,\n  ImageModelV1,\n  TranscriptionModelV1,\n  LanguageModelV1,\n  ProviderV1,\n  SpeechModelV1,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  loadApiKey,\n  withoutTrailingSlash,\n} from '@ai-sdk/provider-utils';\nimport { OpenAIChatLanguageModel } from './openai-chat-language-model';\nimport { OpenAIChatModelId, OpenAIChatSettings } from './openai-chat-settings';\nimport { OpenAICompletionLanguageModel } from './openai-completion-language-model';\nimport {\n  OpenAICompletionModelId,\n  OpenAICompletionSettings,\n} from './openai-completion-settings';\nimport { OpenAIEmbeddingModel } from './openai-embedding-model';\nimport {\n  OpenAIEmbeddingModelId,\n  OpenAIEmbeddingSettings,\n} from './openai-embedding-settings';\nimport { OpenAIImageModel } from './openai-image-model';\nimport {\n  OpenAIImageModelId,\n  OpenAIImageSettings,\n} from './openai-image-settings';\nimport { OpenAITranscriptionModel } from './openai-transcription-model';\nimport { OpenAITranscriptionModelId } from './openai-transcription-settings';\nimport { OpenAIResponsesLanguageModel } from './responses/openai-responses-language-model';\nimport { OpenAIResponsesModelId } from './responses/openai-responses-settings';\nimport { openaiTools } from './openai-tools';\nimport { OpenAISpeechModel } from './openai-speech-model';\nimport { OpenAISpeechModelId } from './openai-speech-settings';\n\nexport interface OpenAIProvider extends ProviderV1 {\n  (\n    modelId: 'gpt-3.5-turbo-instruct',\n    settings?: OpenAICompletionSettings,\n  ): OpenAICompletionLanguageModel;\n  (modelId: OpenAIChatModelId, settings?: OpenAIChatSettings): LanguageModelV1;\n\n  /**\nCreates an OpenAI model for text generation.\n   */\n  languageModel(\n    modelId: 'gpt-3.5-turbo-instruct',\n    settings?: OpenAICompletionSettings,\n  ): OpenAICompletionLanguageModel;\n  languageModel(\n    modelId: OpenAIChatModelId,\n    settings?: OpenAIChatSettings,\n  ): LanguageModelV1;\n\n  /**\nCreates an OpenAI chat model for text generation.\n   */\n  chat(\n    modelId: OpenAIChatModelId,\n    settings?: OpenAIChatSettings,\n  ): LanguageModelV1;\n\n  /**\nCreates an OpenAI responses API model for text generation.\n   */\n  responses(modelId: OpenAIResponsesModelId): LanguageModelV1;\n\n  /**\nCreates an OpenAI completion model for text generation.\n   */\n  completion(\n    modelId: OpenAICompletionModelId,\n    settings?: OpenAICompletionSettings,\n  ): LanguageModelV1;\n\n  /**\nCreates a model for text embeddings.\n   */\n  embedding(\n    modelId: OpenAIEmbeddingModelId,\n    settings?: OpenAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  /**\nCreates a model for text embeddings.\n\n@deprecated Use `textEmbeddingModel` instead.\n   */\n  textEmbedding(\n    modelId: OpenAIEmbeddingModelId,\n    settings?: OpenAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  /**\nCreates a model for text embeddings.\n   */\n  textEmbeddingModel(\n    modelId: OpenAIEmbeddingModelId,\n    settings?: OpenAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  /**\nCreates a model for image generation.\n   */\n  image(\n    modelId: OpenAIImageModelId,\n    settings?: OpenAIImageSettings,\n  ): ImageModelV1;\n\n  /**\nCreates a model for image generation.\n   */\n  imageModel(\n    modelId: OpenAIImageModelId,\n    settings?: OpenAIImageSettings,\n  ): ImageModelV1;\n\n  /**\nCreates a model for transcription.\n   */\n  transcription(modelId: OpenAITranscriptionModelId): TranscriptionModelV1;\n\n  /**\nCreates a model for speech generation.\n   */\n  speech(modelId: OpenAISpeechModelId): SpeechModelV1;\n\n  /**\nOpenAI-specific tools.\n   */\n  tools: typeof openaiTools;\n}\n\nexport interface OpenAIProviderSettings {\n  /**\nBase URL for the OpenAI API calls.\n     */\n  baseURL?: string;\n\n  /**\nAPI key for authenticating requests.\n     */\n  apiKey?: string;\n\n  /**\nOpenAI Organization.\n     */\n  organization?: string;\n\n  /**\nOpenAI project.\n     */\n  project?: string;\n\n  /**\nCustom headers to include in the requests.\n     */\n  headers?: Record<string, string>;\n\n  /**\nOpenAI compatibility mode. Should be set to `strict` when using the OpenAI API,\nand `compatible` when using 3rd party providers. In `compatible` mode, newer\ninformation such as streamOptions are not being sent. Defaults to 'compatible'.\n   */\n  compatibility?: 'strict' | 'compatible';\n\n  /**\nProvider name. Overrides the `openai` default name for 3rd party providers.\n   */\n  name?: string;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n}\n\n/**\nCreate an OpenAI provider instance.\n */\nexport function createOpenAI(\n  options: OpenAIProviderSettings = {},\n): OpenAIProvider {\n  const baseURL =\n    withoutTrailingSlash(options.baseURL) ?? 'https://api.openai.com/v1';\n\n  // we default to compatible, because strict breaks providers like Groq:\n  const compatibility = options.compatibility ?? 'compatible';\n\n  const providerName = options.name ?? 'openai';\n\n  const getHeaders = () => ({\n    Authorization: `Bearer ${loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: 'OPENAI_API_KEY',\n      description: 'OpenAI',\n    })}`,\n    'OpenAI-Organization': options.organization,\n    'OpenAI-Project': options.project,\n    ...options.headers,\n  });\n\n  const createChatModel = (\n    modelId: OpenAIChatModelId,\n    settings: OpenAIChatSettings = {},\n  ) =>\n    new OpenAIChatLanguageModel(modelId, settings, {\n      provider: `${providerName}.chat`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      compatibility,\n      fetch: options.fetch,\n    });\n\n  const createCompletionModel = (\n    modelId: OpenAICompletionModelId,\n    settings: OpenAICompletionSettings = {},\n  ) =>\n    new OpenAICompletionLanguageModel(modelId, settings, {\n      provider: `${providerName}.completion`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      compatibility,\n      fetch: options.fetch,\n    });\n\n  const createEmbeddingModel = (\n    modelId: OpenAIEmbeddingModelId,\n    settings: OpenAIEmbeddingSettings = {},\n  ) =>\n    new OpenAIEmbeddingModel(modelId, settings, {\n      provider: `${providerName}.embedding`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createImageModel = (\n    modelId: OpenAIImageModelId,\n    settings: OpenAIImageSettings = {},\n  ) =>\n    new OpenAIImageModel(modelId, settings, {\n      provider: `${providerName}.image`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createTranscriptionModel = (modelId: OpenAITranscriptionModelId) =>\n    new OpenAITranscriptionModel(modelId, {\n      provider: `${providerName}.transcription`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createSpeechModel = (modelId: OpenAISpeechModelId) =>\n    new OpenAISpeechModel(modelId, {\n      provider: `${providerName}.speech`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createLanguageModel = (\n    modelId: OpenAIChatModelId | OpenAICompletionModelId,\n    settings?: OpenAIChatSettings | OpenAICompletionSettings,\n  ) => {\n    if (new.target) {\n      throw new Error(\n        'The OpenAI model function cannot be called with the new keyword.',\n      );\n    }\n\n    if (modelId === 'gpt-3.5-turbo-instruct') {\n      return createCompletionModel(\n        modelId,\n        settings as OpenAICompletionSettings,\n      );\n    }\n\n    return createChatModel(modelId, settings as OpenAIChatSettings);\n  };\n\n  const createResponsesModel = (modelId: OpenAIResponsesModelId) => {\n    return new OpenAIResponsesLanguageModel(modelId, {\n      provider: `${providerName}.responses`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n  };\n\n  const provider = function (\n    modelId: OpenAIChatModelId | OpenAICompletionModelId,\n    settings?: OpenAIChatSettings | OpenAICompletionSettings,\n  ) {\n    return createLanguageModel(modelId, settings);\n  };\n\n  provider.languageModel = createLanguageModel;\n  provider.chat = createChatModel;\n  provider.completion = createCompletionModel;\n  provider.responses = createResponsesModel;\n  provider.embedding = createEmbeddingModel;\n  provider.textEmbedding = createEmbeddingModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n\n  provider.image = createImageModel;\n  provider.imageModel = createImageModel;\n\n  provider.transcription = createTranscriptionModel;\n  provider.transcriptionModel = createTranscriptionModel;\n\n  provider.speech = createSpeechModel;\n  provider.speechModel = createSpeechModel;\n\n  provider.tools = openaiTools;\n\n  return provider as OpenAIProvider;\n}\n\n/**\nDefault OpenAI provider instance. It uses 'strict' compatibility mode.\n */\nexport const openai = createOpenAI({\n  compatibility: 'strict', // strict for OpenAI API\n});\n","import { createOpenAI } from '@ai-sdk/openai';\nimport type { MastraLanguageModel } from '@mastra/core/agent';\nimport type {\n  KeywordExtractPrompt,\n  QuestionExtractPrompt,\n  SummaryPrompt,\n  TitleExtractorPrompt,\n  TitleCombinePrompt,\n} from '../prompts';\n\nexport type KeywordExtractArgs = {\n  llm?: MastraLanguageModel;\n  keywords?: number;\n  promptTemplate?: KeywordExtractPrompt['template'];\n};\n\nexport type QuestionAnswerExtractArgs = {\n  llm?: MastraLanguageModel;\n  questions?: number;\n  promptTemplate?: QuestionExtractPrompt['template'];\n  embeddingOnly?: boolean;\n};\n\nexport type SummaryExtractArgs = {\n  llm?: MastraLanguageModel;\n  summaries?: string[];\n  promptTemplate?: SummaryPrompt['template'];\n};\n\nexport type TitleExtractorsArgs = {\n  llm?: MastraLanguageModel;\n  nodes?: number;\n  nodeTemplate?: TitleExtractorPrompt['template'];\n  combineTemplate?: TitleCombinePrompt['template'];\n};\n\nexport const STRIP_REGEX = /(\\r\\n|\\n|\\r)/gm;\n\nconst openai = createOpenAI({ apiKey: process.env.OPENAI_API_KEY });\nexport const baseLLM: MastraLanguageModel = openai('gpt-4o');\n","import { Agent } from '@mastra/core/agent';\nimport type { MastraLanguageModel } from '@mastra/core/agent';\nimport { defaultTitleCombinePromptTemplate, defaultTitleExtractorPromptTemplate, PromptTemplate } from '../prompts';\nimport type { TitleCombinePrompt, TitleExtractorPrompt } from '../prompts';\nimport { TextNode } from '../schema';\nimport type { BaseNode } from '../schema';\nimport { BaseExtractor } from './base';\nimport { baseLLM } from './types';\nimport type { TitleExtractorsArgs } from './types';\n\ntype ExtractTitle = {\n  documentTitle: string;\n};\n\n/**\n * Extract title from a list of nodes.\n */\nexport class TitleExtractor extends BaseExtractor {\n  llm: MastraLanguageModel;\n  isTextNodeOnly: boolean = false;\n  nodes: number = 5;\n  nodeTemplate: TitleExtractorPrompt;\n  combineTemplate: TitleCombinePrompt;\n\n  constructor(options?: TitleExtractorsArgs) {\n    super();\n\n    this.llm = options?.llm ?? baseLLM;\n    this.nodes = options?.nodes ?? 5;\n\n    this.nodeTemplate = options?.nodeTemplate\n      ? new PromptTemplate({\n          templateVars: ['context'],\n          template: options.nodeTemplate,\n        })\n      : defaultTitleExtractorPromptTemplate;\n\n    this.combineTemplate = options?.combineTemplate\n      ? new PromptTemplate({\n          templateVars: ['context'],\n          template: options.combineTemplate,\n        })\n      : defaultTitleCombinePromptTemplate;\n  }\n\n  /**\n   * Extract titles from a list of nodes.\n   * @param {BaseNode[]} nodes Nodes to extract titles from.\n   * @returns {Promise<BaseNode<ExtractTitle>[]>} Titles extracted from the nodes.\n   */\n  async extract(nodes: BaseNode[]): Promise<Array<ExtractTitle>> {\n    // Prepare output array in original node order\n    const results: ExtractTitle[] = new Array(nodes.length);\n    // Keep track of nodes with content to extract\n    const nodesToExtractTitle: BaseNode[] = [];\n    const nodeIndexes: number[] = [];\n\n    nodes.forEach((node, idx) => {\n      const text = node.getContent();\n      if (!text || text.trim() === '') {\n        results[idx] = { documentTitle: '' };\n      } else {\n        nodesToExtractTitle.push(node);\n        nodeIndexes.push(idx);\n      }\n    });\n\n    if (nodesToExtractTitle.length) {\n      const filteredNodes = this.filterNodes(nodesToExtractTitle);\n      if (filteredNodes.length) {\n        const nodesByDocument = this.separateNodesByDocument(filteredNodes);\n        const titlesByDocument = await this.extractTitles(nodesByDocument);\n        filteredNodes.forEach((node, i) => {\n          const nodeIndex = nodeIndexes[i];\n          const groupKey = node.sourceNode?.nodeId ?? node.id_;\n          if (typeof nodeIndex === 'number') {\n            results[nodeIndex] = {\n              documentTitle: titlesByDocument[groupKey] ?? '',\n            };\n          }\n        });\n      }\n    }\n    return results;\n  }\n\n  private filterNodes(nodes: BaseNode[]): BaseNode[] {\n    return nodes.filter(node => {\n      if (this.isTextNodeOnly && !(node instanceof TextNode)) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  private separateNodesByDocument(nodes: BaseNode[]): Record<string, BaseNode[]> {\n    const nodesByDocument: Record<string, BaseNode[]> = {};\n\n    for (const node of nodes) {\n      const groupKey = node.sourceNode?.nodeId ?? node.id_;\n      nodesByDocument[groupKey] = nodesByDocument[groupKey] || [];\n      nodesByDocument[groupKey].push(node);\n    }\n\n    return nodesByDocument;\n  }\n\n  private async extractTitles(nodesByDocument: Record<string, BaseNode[]>): Promise<Record<string, string>> {\n    const titlesByDocument: Record<string, string> = {};\n\n    for (const [key, nodes] of Object.entries(nodesByDocument)) {\n      const titleCandidates = await this.getTitlesCandidates(nodes);\n      const combinedTitles = titleCandidates.join(', ');\n\n      let title = '';\n\n      if (this.llm.specificationVersion === 'v2') {\n        const miniAgent = new Agent({\n          model: this.llm,\n          name: 'title-extractor',\n          instructions:\n            'You are a title extractor. You are given a list of nodes and you need to extract the title from the nodes.',\n        });\n        const result = await miniAgent.generate(\n          [{ role: 'user', content: this.combineTemplate.format({ context: combinedTitles }) }],\n          { format: 'mastra' },\n        );\n        title = result.text;\n      } else {\n        const miniAgent = new Agent({\n          model: this.llm,\n          name: 'title-extractor',\n          instructions:\n            'You are a title extractor. You are given a list of nodes and you need to extract the title from the nodes.',\n        });\n        const result = await miniAgent.generateLegacy([\n          { role: 'user', content: this.combineTemplate.format({ context: combinedTitles }) },\n        ]);\n        title = result.text;\n      }\n\n      if (!title) {\n        console.warn('Title extraction LLM output returned empty');\n      }\n\n      titlesByDocument[key] = title;\n    }\n\n    return titlesByDocument;\n  }\n\n  private async getTitlesCandidates(nodes: BaseNode[]): Promise<string[]> {\n    const miniAgent = new Agent({\n      model: this.llm,\n      name: 'titles-candidates-extractor',\n      instructions:\n        'You are a titles candidates extractor. You are given a list of nodes and you need to extract the titles candidates from the nodes.',\n    });\n\n    const titleJobs = nodes.map(async node => {\n      let completion: string;\n      if (this.llm.specificationVersion === 'v2') {\n        const result = await miniAgent.generate(\n          [{ role: 'user', content: this.nodeTemplate.format({ context: node.getContent() }) }],\n          { format: 'mastra' },\n        );\n        completion = result.text;\n      } else {\n        const result = await miniAgent.generateLegacy([\n          { role: 'user', content: this.nodeTemplate.format({ context: node.getContent() }) },\n        ]);\n        completion = result.text;\n      }\n\n      if (!completion) {\n        console.warn('Title candidate extraction LLM output returned empty');\n        return '';\n      }\n\n      return completion.trim();\n    });\n\n    return await Promise.all(titleJobs);\n  }\n}\n","import { Agent } from '@mastra/core/agent';\nimport type { MastraLanguageModel } from '@mastra/core/agent';\nimport { PromptTemplate, defaultSummaryPrompt } from '../prompts';\nimport type { SummaryPrompt } from '../prompts';\nimport type { BaseNode } from '../schema';\nimport { TextNode } from '../schema';\nimport { BaseExtractor } from './base';\nimport { baseLLM, STRIP_REGEX } from './types';\nimport type { SummaryExtractArgs } from './types';\n\ntype ExtractSummary = {\n  sectionSummary?: string;\n  prevSectionSummary?: string;\n  nextSectionSummary?: string;\n};\n\n/**\n * Summarize an array of nodes using a custom LLM.\n *\n * @param nodes Array of node-like objects\n * @param options Summary extraction options\n * @returns Array of summary results\n */\nexport class SummaryExtractor extends BaseExtractor {\n  private llm: MastraLanguageModel;\n  summaries: string[];\n  promptTemplate: SummaryPrompt;\n  private selfSummary: boolean;\n  private prevSummary: boolean;\n  private nextSummary: boolean;\n  constructor(options?: SummaryExtractArgs) {\n    const summaries = options?.summaries ?? ['self'];\n\n    if (summaries && !summaries.some(s => ['self', 'prev', 'next'].includes(s)))\n      throw new Error(\"Summaries must be one of 'self', 'prev', 'next'\");\n\n    super();\n\n    this.llm = options?.llm ?? baseLLM;\n    this.summaries = summaries;\n    this.promptTemplate = options?.promptTemplate\n      ? new PromptTemplate({\n          templateVars: ['context'],\n          template: options.promptTemplate,\n        })\n      : defaultSummaryPrompt;\n\n    this.selfSummary = summaries?.includes('self') ?? false;\n    this.prevSummary = summaries?.includes('prev') ?? false;\n    this.nextSummary = summaries?.includes('next') ?? false;\n  }\n\n  /**\n   * Extract summary from a node.\n   * @param {BaseNode} node Node to extract summary from.\n   * @returns {Promise<string>} Summary extracted from the node.\n   */\n  async generateNodeSummary(node: BaseNode): Promise<string> {\n    const text = node.getContent();\n    if (!text || text.trim() === '') {\n      return '';\n    }\n    if (this.isTextNodeOnly && !(node instanceof TextNode)) {\n      return '';\n    }\n    const context = node.getContent();\n\n    const prompt = this.promptTemplate.format({\n      context,\n    });\n\n    const miniAgent = new Agent({\n      model: this.llm,\n      name: 'summary-extractor',\n      instructions:\n        'You are a summary extractor. You are given a node and you need to extract the summary from the node.',\n    });\n\n    let summary = '';\n    if (this.llm.specificationVersion === 'v2') {\n      const result = await miniAgent.generate([{ role: 'user', content: prompt }], { format: 'mastra' });\n      summary = result.text;\n    } else {\n      const result = await miniAgent.generateLegacy([{ role: 'user', content: prompt }]);\n      summary = result.text;\n    }\n\n    if (!summary) {\n      console.warn('Summary extraction LLM output returned empty');\n      return '';\n    }\n\n    return summary.replace(STRIP_REGEX, '');\n  }\n\n  /**\n   * Extract summaries from a list of nodes.\n   * @param {BaseNode[]} nodes Nodes to extract summaries from.\n   * @returns {Promise<ExtractSummary[]>} Summaries extracted from the nodes.\n   */\n  async extract(nodes: BaseNode[]): Promise<ExtractSummary[]> {\n    if (!nodes.every(n => n instanceof TextNode)) throw new Error('Only `TextNode` is allowed for `Summary` extractor');\n\n    const nodeSummaries = await Promise.all(nodes.map(node => this.generateNodeSummary(node)));\n\n    const metadataList: ExtractSummary[] = nodes.map(() => ({}));\n\n    for (let i = 0; i < nodes.length; i++) {\n      if (i > 0 && this.prevSummary && nodeSummaries[i - 1]) {\n        metadataList[i]!['prevSectionSummary'] = nodeSummaries[i - 1];\n      }\n      if (i < nodes.length - 1 && this.nextSummary && nodeSummaries[i + 1]) {\n        metadataList[i]!['nextSectionSummary'] = nodeSummaries[i + 1];\n      }\n      if (this.selfSummary && nodeSummaries[i]) {\n        metadataList[i]!['sectionSummary'] = nodeSummaries[i];\n      }\n    }\n\n    return metadataList;\n  }\n}\n","import { Agent } from '@mastra/core/agent';\nimport type { MastraLanguageModel } from '@mastra/core/agent';\nimport { PromptTemplate, defaultQuestionExtractPrompt } from '../prompts';\nimport type { QuestionExtractPrompt } from '../prompts';\nimport type { BaseNode } from '../schema';\nimport { TextNode } from '../schema';\nimport { BaseExtractor } from './base';\nimport { baseLLM, STRIP_REGEX } from './types';\nimport type { QuestionAnswerExtractArgs } from './types';\n\ntype ExtractQuestion = {\n  /**\n   * Questions extracted from the node as a string (may be empty if extraction fails).\n   */\n  questionsThisExcerptCanAnswer: string;\n};\n\n/**\n * Extract questions from a list of nodes.\n */\nexport class QuestionsAnsweredExtractor extends BaseExtractor {\n  llm: MastraLanguageModel;\n  questions: number = 5;\n  promptTemplate: QuestionExtractPrompt;\n  embeddingOnly: boolean = false;\n\n  /**\n   * Constructor for the QuestionsAnsweredExtractor class.\n   * @param {MastraLanguageModel} llm MastraLanguageModel instance.\n   * @param {number} questions Number of questions to generate.\n   * @param {QuestionExtractPrompt['template']} promptTemplate Optional custom prompt template (should include {context}).\n   * @param {boolean} embeddingOnly Whether to use metadata for embeddings only.\n   */\n  constructor(options?: QuestionAnswerExtractArgs) {\n    if (options?.questions && options.questions < 1) throw new Error('Questions must be greater than 0');\n\n    super();\n\n    this.llm = options?.llm ?? baseLLM;\n    this.questions = options?.questions ?? 5;\n    this.promptTemplate = options?.promptTemplate\n      ? new PromptTemplate({\n          templateVars: ['numQuestions', 'context'],\n          template: options.promptTemplate,\n        }).partialFormat({\n          numQuestions: '5',\n        })\n      : defaultQuestionExtractPrompt;\n    this.embeddingOnly = options?.embeddingOnly ?? false;\n  }\n\n  /**\n   * Extract answered questions from a node.\n   * @param {BaseNode} node Node to extract questions from.\n   * @returns {Promise<Array<ExtractQuestion> | Array<{}>>} Questions extracted from the node.\n   */\n  async extractQuestionsFromNode(node: BaseNode): Promise<ExtractQuestion> {\n    const text = node.getContent();\n    if (!text || text.trim() === '') {\n      return { questionsThisExcerptCanAnswer: '' };\n    }\n    if (this.isTextNodeOnly && !(node instanceof TextNode)) {\n      return { questionsThisExcerptCanAnswer: '' };\n    }\n\n    const contextStr = node.getContent();\n\n    const prompt = this.promptTemplate.format({\n      context: contextStr,\n      numQuestions: this.questions.toString(),\n    });\n\n    const miniAgent = new Agent({\n      model: this.llm,\n      name: 'question-extractor',\n      instructions:\n        'You are a question extractor. You are given a node and you need to extract the questions from the node.',\n    });\n\n    let questionsText = '';\n    if (this.llm.specificationVersion === 'v2') {\n      const result = await miniAgent.generate([{ role: 'user', content: prompt }], { format: 'mastra' });\n      questionsText = result.text;\n    } else {\n      const result = await miniAgent.generateLegacy([{ role: 'user', content: prompt }]);\n      questionsText = result.text;\n    }\n\n    if (!questionsText) {\n      console.warn('Question extraction LLM output returned empty');\n      return { questionsThisExcerptCanAnswer: '' };\n    }\n\n    const result = questionsText.replace(STRIP_REGEX, '').trim();\n\n    return {\n      questionsThisExcerptCanAnswer: result,\n    };\n  }\n\n  /**\n   * Extract answered questions from a list of nodes.\n   * @param {BaseNode[]} nodes Nodes to extract questions from.\n   * @returns {Promise<Array<ExtractQuestion> | Array<{}>>} Questions extracted from the nodes.\n   */\n  async extract(nodes: BaseNode[]): Promise<Array<ExtractQuestion> | Array<object>> {\n    const results = await Promise.all(nodes.map(node => this.extractQuestionsFromNode(node)));\n\n    return results;\n  }\n}\n","import { Agent } from '@mastra/core/agent';\nimport type { MastraLanguageModel } from '@mastra/core/agent';\nimport { defaultKeywordExtractPrompt, PromptTemplate } from '../prompts';\nimport type { KeywordExtractPrompt } from '../prompts';\nimport type { BaseNode } from '../schema';\nimport { TextNode } from '../schema';\nimport { BaseExtractor } from './base';\nimport { baseLLM } from './types';\nimport type { KeywordExtractArgs } from './types';\n\ntype ExtractKeyword = {\n  /**\n   * Comma-separated keywords extracted from the node. May be empty if extraction fails.\n   */\n  excerptKeywords: string;\n};\n\n/**\n * Extract keywords from a list of nodes.\n */\nexport class KeywordExtractor extends BaseExtractor {\n  llm: MastraLanguageModel;\n  keywords: number = 5;\n  promptTemplate: KeywordExtractPrompt;\n\n  /**\n   * Constructor for the KeywordExtractor class.\n   * @param {MastraLanguageModel} llm MastraLanguageModel instance.\n   * @param {number} keywords Number of keywords to extract.\n   * @param {string} [promptTemplate] Optional custom prompt template (must include {context})\n   * @throws {Error} If keywords is less than 1.\n   */\n  constructor(options?: KeywordExtractArgs) {\n    if (options?.keywords && options.keywords < 1) throw new Error('Keywords must be greater than 0');\n\n    super();\n\n    this.llm = options?.llm ?? baseLLM;\n    this.keywords = options?.keywords ?? 5;\n    this.promptTemplate = options?.promptTemplate\n      ? new PromptTemplate({\n          templateVars: ['context', 'maxKeywords'],\n          template: options.promptTemplate,\n        })\n      : defaultKeywordExtractPrompt;\n  }\n\n  /**\n   *\n   * @param node Node to extract keywords from.\n   * @returns Keywords extracted from the node.\n   */\n  /**\n   * Extract keywords from a node. Returns an object with a comma-separated string of keywords, or an empty string if extraction fails.\n   * Adds error handling for malformed/empty LLM output.\n   */\n  async extractKeywordsFromNodes(node: BaseNode): Promise<ExtractKeyword> {\n    const text = node.getContent();\n    if (!text || text.trim() === '') {\n      return { excerptKeywords: '' };\n    }\n    if (this.isTextNodeOnly && !(node instanceof TextNode)) {\n      return { excerptKeywords: '' };\n    }\n\n    let keywords = '';\n    try {\n      const miniAgent = new Agent({\n        model: this.llm,\n        name: 'keyword-extractor',\n        instructions:\n          'You are a keyword extractor. You are given a node and you need to extract the keywords from the node.',\n      });\n\n      if (this.llm.specificationVersion === 'v2') {\n        const result = await miniAgent.generate(\n          [\n            {\n              role: 'user',\n              content: this.promptTemplate.format({\n                context: node.getContent(),\n                maxKeywords: this.keywords.toString(),\n              }),\n            },\n          ],\n          { format: 'mastra' },\n        );\n        keywords = result.text;\n      } else {\n        const result = await miniAgent.generateLegacy([\n          {\n            role: 'user',\n            content: this.promptTemplate.format({ context: node.getContent(), maxKeywords: this.keywords.toString() }),\n          },\n        ]);\n        keywords = result.text;\n      }\n\n      if (!keywords) {\n        console.warn('Keyword extraction LLM output returned empty');\n        return { excerptKeywords: '' };\n      }\n\n      return { excerptKeywords: keywords.trim() };\n    } catch (err) {\n      console.warn('Keyword extraction failed:', err);\n      return { excerptKeywords: '' };\n    }\n  }\n\n  /**\n   *\n   * @param nodes Nodes to extract keywords from.\n   * @returns Keywords extracted from the nodes.\n   */\n  /**\n   * Extract keywords from an array of nodes. Always returns an array (may be empty).\n   * @param nodes Nodes to extract keywords from.\n   * @returns Array of keyword extraction results.\n   */\n  async extract(nodes: BaseNode[]): Promise<Array<ExtractKeyword>> {\n    if (!Array.isArray(nodes) || nodes.length === 0) return [];\n    const results = await Promise.all(nodes.map(node => this.extractKeywordsFromNodes(node)));\n    return results;\n  }\n}\n","import type { TiktokenEncoding, TiktokenModel } from 'js-tiktoken';\nimport type {\n  TitleExtractorsArgs,\n  SummaryExtractArgs,\n  QuestionAnswerExtractArgs,\n  KeywordExtractArgs,\n} from './extractors';\n\nexport enum Language {\n  CPP = 'cpp',\n  GO = 'go',\n  JAVA = 'java',\n  KOTLIN = 'kotlin',\n  JS = 'js',\n  TS = 'ts',\n  PHP = 'php',\n  PROTO = 'proto',\n  PYTHON = 'python',\n  RST = 'rst',\n  RUBY = 'ruby',\n  RUST = 'rust',\n  SCALA = 'scala',\n  SWIFT = 'swift',\n  MARKDOWN = 'markdown',\n  LATEX = 'latex',\n  HTML = 'html',\n  SOL = 'sol',\n  CSHARP = 'csharp',\n  COBOL = 'cobol',\n  C = 'c',\n  LUA = 'lua',\n  PERL = 'perl',\n  HASKELL = 'haskell',\n  ELIXIR = 'elixir',\n  POWERSHELL = 'powershell',\n}\n\nexport type ExtractParams = {\n  title?: TitleExtractorsArgs | boolean;\n  summary?: SummaryExtractArgs | boolean;\n  questions?: QuestionAnswerExtractArgs | boolean;\n  keywords?: KeywordExtractArgs | boolean;\n};\n\nexport type BaseChunkOptions = {\n  /**\n   * @deprecated Use `maxSize` instead. Will be removed in next major version.\n   */\n  size?: number;\n  maxSize?: number;\n  overlap?: number;\n  lengthFunction?: (text: string) => number;\n  keepSeparator?: boolean | 'start' | 'end';\n  addStartIndex?: boolean;\n  stripWhitespace?: boolean;\n};\n\nexport type CharacterChunkOptions = BaseChunkOptions & {\n  separator?: string;\n  isSeparatorRegex?: boolean;\n};\n\nexport type RecursiveChunkOptions = BaseChunkOptions & {\n  separators?: string[];\n  isSeparatorRegex?: boolean;\n  language?: Language;\n};\n\nexport type TokenChunkOptions = BaseChunkOptions & {\n  encodingName?: TiktokenEncoding;\n  modelName?: TiktokenModel;\n  allowedSpecial?: Set<string> | 'all';\n  disallowedSpecial?: Set<string> | 'all';\n};\n\nexport type MarkdownChunkOptions = BaseChunkOptions & {\n  headers?: [string, string][];\n  returnEachLine?: boolean;\n  stripHeaders?: boolean;\n};\n\nexport type SemanticMarkdownChunkOptions = BaseChunkOptions & {\n  joinThreshold?: number;\n  encodingName?: TiktokenEncoding;\n  modelName?: TiktokenModel;\n  allowedSpecial?: Set<string> | 'all';\n  disallowedSpecial?: Set<string> | 'all';\n};\n\nexport type HTMLChunkOptions = BaseChunkOptions &\n  (\n    | { headers: [string, string][]; sections?: never; returnEachLine?: boolean }\n    | { sections: [string, string][]; headers?: never }\n  ) & { returnEachLine?: boolean };\n\nexport type JsonChunkOptions = BaseChunkOptions & {\n  minSize?: number;\n  ensureAscii?: boolean;\n  convertLists?: boolean;\n};\n\nexport type LatexChunkOptions = BaseChunkOptions & {};\n\nexport type SentenceChunkOptions = BaseChunkOptions & {\n  maxSize: number; // Override to make required for sentence strategy\n  minSize?: number;\n  targetSize?: number;\n  sentenceEnders?: string[];\n  fallbackToWords?: boolean;\n  fallbackToCharacters?: boolean;\n};\n\nexport type StrategyOptions = {\n  recursive: RecursiveChunkOptions;\n  character: CharacterChunkOptions;\n  token: TokenChunkOptions;\n  markdown: MarkdownChunkOptions;\n  html: HTMLChunkOptions;\n  json: JsonChunkOptions;\n  latex: LatexChunkOptions;\n  sentence: SentenceChunkOptions;\n  'semantic-markdown': SemanticMarkdownChunkOptions;\n};\n\nexport type ChunkStrategy =\n  | 'recursive'\n  | 'character'\n  | 'token'\n  | 'markdown'\n  | 'html'\n  | 'json'\n  | 'latex'\n  | 'sentence'\n  | 'semantic-markdown';\n\nexport type ChunkParams =\n  | ({ strategy?: 'character' } & CharacterChunkOptions & { extract?: ExtractParams })\n  | ({ strategy: 'recursive' } & RecursiveChunkOptions & { extract?: ExtractParams })\n  | ({ strategy: 'token' } & TokenChunkOptions & { extract?: ExtractParams })\n  | ({ strategy: 'markdown' } & MarkdownChunkOptions & { extract?: ExtractParams })\n  | ({ strategy: 'html' } & HTMLChunkOptions & { extract?: ExtractParams })\n  | ({ strategy: 'json' } & JsonChunkOptions & { extract?: ExtractParams })\n  | ({ strategy: 'latex' } & LatexChunkOptions & { extract?: ExtractParams })\n  | ({ strategy: 'sentence' } & SentenceChunkOptions & { extract?: ExtractParams })\n  | ({ strategy: 'semantic-markdown' } & SemanticMarkdownChunkOptions & { extract?: ExtractParams });\n","import { Document } from '../schema';\n\nimport type { BaseChunkOptions } from '../types';\n\nimport type { Transformer } from './transformer';\n\nexport abstract class TextTransformer implements Transformer {\n  protected maxSize: number;\n  protected overlap: number;\n  protected lengthFunction: (text: string) => number;\n  protected keepSeparator: boolean | 'start' | 'end';\n  protected addStartIndex: boolean;\n  protected stripWhitespace: boolean;\n\n  constructor({\n    maxSize = 4000,\n    overlap = 200,\n    lengthFunction = (text: string) => text.length,\n    keepSeparator = false,\n    addStartIndex = false,\n    stripWhitespace = true,\n  }: BaseChunkOptions) {\n    if (overlap > maxSize) {\n      throw new Error(`Got a larger chunk overlap (${overlap}) than chunk size ` + `(${maxSize}), should be smaller.`);\n    }\n    this.maxSize = maxSize;\n    this.overlap = overlap;\n    this.lengthFunction = lengthFunction;\n    this.keepSeparator = keepSeparator;\n    this.addStartIndex = addStartIndex;\n    this.stripWhitespace = stripWhitespace;\n  }\n\n  setAddStartIndex(value: boolean): void {\n    this.addStartIndex = value;\n  }\n\n  abstract splitText({ text }: { text: string }): string[];\n\n  createDocuments(texts: string[], metadatas?: Record<string, any>[]): Document[] {\n    const _metadatas = metadatas || Array(texts.length).fill({});\n    const documents: Document[] = [];\n\n    texts.forEach((text, i) => {\n      let index = 0;\n      let previousChunkLen = 0;\n\n      this.splitText({ text }).forEach(chunk => {\n        const metadata = { ..._metadatas[i] };\n        if (this.addStartIndex) {\n          const offset = index + previousChunkLen - this.overlap;\n          index = text.indexOf(chunk, Math.max(0, offset));\n          metadata.startIndex = index;\n          previousChunkLen = chunk.length;\n        }\n        documents.push(\n          new Document({\n            text: chunk,\n            metadata,\n          }),\n        );\n      });\n    });\n\n    return documents;\n  }\n\n  splitDocuments(documents: Document[]): Document[] {\n    const texts: string[] = [];\n    const metadatas: Record<string, any>[] = [];\n    for (const doc of documents) {\n      texts.push(doc.text);\n      metadatas.push(doc.metadata);\n    }\n    return this.createDocuments(texts, metadatas);\n  }\n\n  transformDocuments(documents: Document[]): Document[] {\n    const texts: string[] = [];\n    const metadatas: Record<string, any>[] = [];\n\n    for (const doc of documents) {\n      texts.push(doc.text);\n      metadatas.push(doc.metadata);\n    }\n\n    return this.createDocuments(texts, metadatas);\n  }\n\n  protected joinDocs(docs: string[], separator: string): string | null {\n    let text = docs.join(separator);\n    if (this.stripWhitespace) {\n      text = text.trim();\n    }\n    return text === '' ? null : text;\n  }\n\n  protected mergeSplits(splits: string[], separator: string): string[] {\n    const docs: string[] = [];\n    let currentDoc: string[] = [];\n    let total = 0;\n\n    for (const d of splits) {\n      const len = this.lengthFunction(d);\n      const separatorLen = separator ? this.lengthFunction(separator) : 0;\n\n      if (total + len + (currentDoc.length > 0 ? separatorLen : 0) > this.maxSize) {\n        if (total > this.maxSize) {\n          console.warn(`Created a chunk of size ${total}, which is longer than the specified ${this.maxSize}`);\n        }\n\n        if (currentDoc.length > 0) {\n          const doc = this.joinDocs(currentDoc, separator);\n          if (doc !== null) {\n            docs.push(doc);\n          }\n\n          // Handle overlap: keep enough content from the end of current chunk\n          if (this.overlap > 0) {\n            let overlapContent: string[] = [];\n            let overlapSize = 0;\n\n            // Work backwards through currentDoc until we have enough overlap\n            for (let i = currentDoc.length - 1; i >= 0; i--) {\n              const piece = currentDoc[i]!;\n              const pieceLen = this.lengthFunction(piece);\n\n              if (overlapSize + pieceLen > this.overlap) {\n                break;\n              }\n\n              overlapContent.unshift(piece);\n              overlapSize += pieceLen + (overlapContent.length > 1 ? separatorLen : 0);\n            }\n\n            currentDoc = overlapContent;\n            total = overlapSize;\n          } else {\n            currentDoc = [];\n            total = 0;\n          }\n        }\n      }\n\n      currentDoc.push(d);\n      total += len + (currentDoc.length > 1 ? separatorLen : 0);\n    }\n\n    if (currentDoc.length > 0) {\n      const doc = this.joinDocs(currentDoc, separator);\n      if (doc !== null) {\n        docs.push(doc);\n      }\n    }\n\n    return docs;\n  }\n}\n","import { Language } from '../types';\nimport type { BaseChunkOptions, CharacterChunkOptions, RecursiveChunkOptions } from '../types';\n\nimport { TextTransformer } from './text';\n\nfunction splitTextWithRegex(text: string, separator: string, keepSeparator: boolean | 'start' | 'end'): string[] {\n  if (!separator) {\n    return text.split('');\n  }\n\n  if (!keepSeparator) {\n    return text.split(new RegExp(separator)).filter(s => s !== '');\n  }\n\n  if (!text) {\n    return [];\n  }\n\n  // Split with capturing group to keep separators\n  const splits = text.split(new RegExp(`(${separator})`));\n  const result: string[] = [];\n\n  if (keepSeparator === 'end') {\n    // Process all complete pairs\n    for (let i = 0; i < splits.length - 1; i += 2) {\n      if (i + 1 < splits.length) {\n        // Current text + separator\n        const chunk = splits[i] + (splits[i + 1] || '');\n        if (chunk) result.push(chunk);\n      }\n    }\n    // Handle the last element if it exists and isn't a separator\n    if (splits.length % 2 === 1 && splits[splits.length - 1]) {\n      result.push(splits?.[splits.length - 1]!);\n    }\n  } else {\n    if (splits[0]) result.push(splits[0]);\n\n    for (let i = 1; i < splits.length - 1; i += 2) {\n      const separator = splits[i];\n      const text = splits[i + 1];\n      if (separator && text) {\n        result.push(separator + text);\n      }\n    }\n  }\n\n  return result.filter(s => s !== '');\n}\n\nexport class CharacterTransformer extends TextTransformer {\n  protected separator: string;\n  protected isSeparatorRegex: boolean;\n\n  constructor({ separator = '\\n\\n', isSeparatorRegex = false, ...baseOptions }: CharacterChunkOptions = {}) {\n    super(baseOptions);\n    this.separator = separator;\n    this.isSeparatorRegex = isSeparatorRegex;\n  }\n\n  splitText({ text }: { text: string }): string[] {\n    // First, split the text into initial chunks\n    const separator = this.isSeparatorRegex ? this.separator : this.separator.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n    const initialSplits = splitTextWithRegex(text, separator, this.keepSeparator);\n\n    // If length of any split is greater than chunk size, perform additional splitting\n    const chunks: string[] = [];\n    for (const split of initialSplits) {\n      if (this.lengthFunction(split) <= this.maxSize) {\n        chunks.push(split);\n      } else {\n        // If a single split is too large, split it further with overlap\n        const subChunks = this.__splitChunk(split);\n        chunks.push(...subChunks);\n      }\n    }\n\n    return chunks;\n  }\n\n  private __splitChunk(text: string): string[] {\n    const chunks: string[] = [];\n    let currentPosition = 0;\n\n    while (currentPosition < text.length) {\n      let chunkEnd = currentPosition;\n\n      // Build chunk up to max size\n      while (chunkEnd < text.length && this.lengthFunction(text.slice(currentPosition, chunkEnd + 1)) <= this.maxSize) {\n        chunkEnd++;\n      }\n\n      const currentChunk = text.slice(currentPosition, chunkEnd);\n      const chunkLength = this.lengthFunction(currentChunk);\n      chunks.push(currentChunk);\n\n      // If we're at the end, break to avoid tiny chunks\n      if (chunkEnd >= text.length) break;\n\n      // Move position forward by chunk size minus overlap\n      currentPosition += Math.max(1, chunkLength - this.overlap);\n    }\n\n    return chunks;\n  }\n}\n\nexport class RecursiveCharacterTransformer extends TextTransformer {\n  protected separators: string[];\n  protected isSeparatorRegex: boolean;\n\n  constructor({ separators, isSeparatorRegex = false, language, ...baseOptions }: RecursiveChunkOptions = {}) {\n    super(baseOptions);\n    this.separators = separators || ['\\n\\n', '\\n', ' ', ''];\n    this.isSeparatorRegex = isSeparatorRegex;\n  }\n\n  private _splitText(text: string, separators: string[]): string[] {\n    const finalChunks: string[] = [];\n\n    let separator = separators?.[separators.length - 1]!;\n    let newSeparators: string[] = [];\n\n    for (let i = 0; i < separators.length; i++) {\n      const s = separators[i]!;\n      const _separator = this.isSeparatorRegex ? s : s?.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n      if (s === '') {\n        separator = s;\n        break;\n      }\n\n      if (new RegExp(_separator).test(text)) {\n        separator = s;\n        newSeparators = separators.slice(i + 1);\n        break;\n      }\n    }\n\n    const _separator = this.isSeparatorRegex ? separator : separator?.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n    const splits = splitTextWithRegex(text, _separator, this.keepSeparator);\n\n    const goodSplits: string[] = [];\n    const mergeSeparator = this.keepSeparator ? '' : separator;\n\n    for (const s of splits) {\n      if (this.lengthFunction(s) < this.maxSize) {\n        goodSplits.push(s);\n      } else {\n        if (goodSplits.length > 0) {\n          const mergedText = this.mergeSplits(goodSplits, mergeSeparator);\n          finalChunks.push(...mergedText);\n          goodSplits.length = 0;\n        }\n        if (newSeparators.length === 0) {\n          finalChunks.push(s);\n        } else {\n          const otherInfo = this._splitText(s, newSeparators);\n          finalChunks.push(...otherInfo);\n        }\n      }\n    }\n\n    if (goodSplits.length > 0) {\n      const mergedText = this.mergeSplits(goodSplits, mergeSeparator);\n      finalChunks.push(...mergedText);\n    }\n\n    return finalChunks;\n  }\n\n  splitText({ text }: { text: string }): string[] {\n    return this._splitText(text, this.separators);\n  }\n\n  static fromLanguage(language: Language, options: BaseChunkOptions = {}): RecursiveCharacterTransformer {\n    const separators = RecursiveCharacterTransformer.getSeparatorsForLanguage(language);\n    return new RecursiveCharacterTransformer({\n      ...options,\n      separators,\n      isSeparatorRegex: true,\n      language,\n    });\n  }\n\n  static getSeparatorsForLanguage(language: Language): string[] {\n    switch (language) {\n      case Language.MARKDOWN:\n        return [\n          // First, try to split along Markdown headings (starting with level 2)\n          '\\n#{1,6} ',\n          // End of code block\n          '```\\n',\n          // Horizontal lines\n          '\\n\\\\*\\\\*\\\\*+\\n',\n          '\\n---+\\n',\n          '\\n___+\\n',\n          // Note that this splitter doesn't handle horizontal lines defined\n          // by *three or more* of ***, ---, or ___, but this is not handled\n          '\\n\\n',\n          '\\n',\n          ' ',\n          '',\n        ];\n      case Language.CPP:\n      case Language.C:\n        return [\n          '\\nclass ',\n          '\\nvoid ',\n          '\\nint ',\n          '\\nfloat ',\n          '\\ndouble ',\n          '\\nif ',\n          '\\nfor ',\n          '\\nwhile ',\n          '\\nswitch ',\n          '\\ncase ',\n          '\\n\\n',\n          '\\n',\n          ' ',\n          '',\n        ];\n      case Language.TS:\n        return [\n          '\\nenum ',\n          '\\ninterface ',\n          '\\nnamespace ',\n          '\\ntype ',\n          '\\nclass ',\n          '\\nfunction ',\n          '\\nconst ',\n          '\\nlet ',\n          '\\nvar ',\n          '\\nif ',\n          '\\nfor ',\n          '\\nwhile ',\n          '\\nswitch ',\n          '\\ncase ',\n          '\\ndefault ',\n          '\\n\\n',\n          '\\n',\n          ' ',\n          '',\n        ];\n      case Language.LATEX:\n        return [\n          '\\\\\\\\part\\\\*?\\\\{',\n          '\\\\\\\\chapter\\\\*?\\\\{',\n          '\\\\\\\\section\\\\*?\\\\{',\n          '\\\\\\\\subsection\\\\*?\\\\{',\n          '\\\\\\\\subsubsection\\\\*?\\\\{',\n          '\\\\\\\\begin\\\\{.*?\\\\}',\n          '\\\\\\\\end\\\\{.*?\\\\}',\n          '\\\\\\\\[a-zA-Z]+\\\\{.*?\\\\}',\n          '\\n\\n',\n          '\\n',\n          ' ',\n          '',\n        ];\n      // ... (add other language cases following the same pattern)\n      default:\n        throw new Error(`Language ${language} is not supported! Please choose from ${Object.values(Language)}`);\n    }\n  }\n}\n","import { parse } from 'node-html-better-parser';\nimport { Document } from '../schema';\nimport type { HTMLChunkOptions } from '../types';\n\nimport { RecursiveCharacterTransformer } from './character';\n\ninterface ElementType {\n  url: string;\n  xpath: string;\n  content: string;\n  metadata: Record<string, string>;\n}\n\nexport class HTMLHeaderTransformer {\n  private headersToSplitOn: [string, string][];\n  private returnEachElement: boolean;\n\n  constructor(options: HTMLChunkOptions & { headers: [string, string][] }) {\n    this.returnEachElement = options.returnEachLine ?? false;\n    this.headersToSplitOn = [...options.headers].sort();\n  }\n\n  splitText({ text }: { text: string }): Document[] {\n    const root = parse(text);\n\n    const headerFilter = this.headersToSplitOn.map(([header]) => header);\n    const headerMapping = Object.fromEntries(this.headersToSplitOn);\n\n    const elements: ElementType[] = [];\n    const headers = root.querySelectorAll(headerFilter.join(','));\n\n    headers.forEach(header => {\n      let content = '';\n      const parentNode = header.parentNode;\n\n      if (parentNode && parentNode.childNodes) {\n        let foundHeader = false;\n        for (const node of parentNode.childNodes) {\n          // Start collecting content after we find our header\n          if (node === header) {\n            foundHeader = true;\n            continue;\n          }\n\n          // If we found our header and hit another header, stop\n          // @ts-expect-error - node.tagName is not defined on type Node\n          if (foundHeader && node.tagName && headerFilter.includes(node.tagName.toLowerCase())) {\n            break;\n          }\n\n          // Collect content between headers\n          if (foundHeader) {\n            content += this.getTextContent(node) + ' ';\n          }\n        }\n      }\n\n      elements.push({\n        url: text,\n        xpath: this.getXPath(header),\n        content: content.trim(),\n        metadata: {\n          [headerMapping?.[header.tagName.toLowerCase()]!]: header.text || '',\n        },\n      });\n    });\n\n    return this.returnEachElement\n      ? elements.map(\n          el =>\n            new Document({\n              text: el.content,\n              metadata: { ...el.metadata, xpath: el.xpath },\n            }),\n        )\n      : this.aggregateElementsToChunks(elements);\n  }\n\n  private getXPath(element: any): string {\n    if (!element) return '';\n\n    const parts: string[] = [];\n    let current = element;\n\n    while (current && current.tagName) {\n      let index = 1;\n      const parent = current.parentNode;\n\n      if (parent && parent.childNodes) {\n        // Count preceding siblings with same tag\n        for (const sibling of parent.childNodes) {\n          if (sibling === current) break;\n          if (sibling.tagName === current.tagName) {\n            index++;\n          }\n        }\n      }\n\n      parts.unshift(`${current.tagName.toLowerCase()}[${index}]`);\n      current = current.parentNode;\n    }\n\n    return '/' + parts.join('/');\n  }\n\n  private getTextContent(element: any): string {\n    if (!element) return '';\n\n    // For text nodes, return their content\n    if (!element.tagName) {\n      return element.text || '';\n    }\n\n    // For element nodes, combine their text with children's text\n    let content = element.text || '';\n\n    if (element.childNodes) {\n      for (const child of element.childNodes) {\n        const childText = this.getTextContent(child);\n        if (childText) {\n          content += ' ' + childText;\n        }\n      }\n    }\n\n    return content.trim();\n  }\n\n  private aggregateElementsToChunks(elements: ElementType[]): Document[] {\n    const aggregatedChunks: ElementType[] = [];\n\n    for (const element of elements) {\n      if (\n        aggregatedChunks.length > 0 &&\n        JSON.stringify(aggregatedChunks[aggregatedChunks.length - 1]!.metadata) === JSON.stringify(element.metadata)\n      ) {\n        // If the last element has the same metadata, append content\n        aggregatedChunks[aggregatedChunks.length - 1]!.content += '  \\n' + element.content;\n      } else {\n        // Otherwise, add as new element\n        aggregatedChunks.push({ ...element });\n      }\n    }\n\n    return aggregatedChunks.map(\n      chunk =>\n        new Document({\n          text: chunk.content,\n          metadata: { ...chunk.metadata, xpath: chunk.xpath },\n        }),\n    );\n  }\n\n  createDocuments(texts: string[], metadatas?: Record<string, any>[]): Document[] {\n    const _metadatas = metadatas || Array(texts.length).fill({});\n    const documents: Document[] = [];\n\n    for (let i = 0; i < texts.length; i++) {\n      const chunks = this.splitText({ text: texts[i]! });\n      for (const chunk of chunks) {\n        const metadata = { ...(_metadatas[i] || {}) };\n        const chunkMetadata = chunk.metadata;\n\n        if (chunkMetadata) {\n          for (const [key, value] of Object.entries(chunkMetadata || {})) {\n            if (value === '#TITLE#') {\n              chunkMetadata[key] = metadata['Title'];\n            }\n          }\n        }\n\n        documents.push(\n          new Document({\n            text: chunk.text!,\n            metadata: { ...metadata, ...chunkMetadata },\n          }),\n        );\n      }\n    }\n\n    return documents;\n  }\n\n  transformDocuments(documents: Document[]): Document[] {\n    const texts: string[] = [];\n    const metadatas: Record<string, any>[] = [];\n\n    for (const doc of documents) {\n      texts.push(doc.text);\n      metadatas.push(doc.metadata);\n    }\n\n    return this.createDocuments(texts, metadatas);\n  }\n}\n\nexport class HTMLSectionTransformer {\n  private headersToSplitOn: Record<string, string>;\n  private textSplitter: RecursiveCharacterTransformer;\n\n  constructor(options: HTMLChunkOptions & { sections: [string, string][] }) {\n    this.headersToSplitOn = Object.fromEntries(options.sections.map(([tag, name]) => [tag.toLowerCase(), name]));\n    this.textSplitter = new RecursiveCharacterTransformer(options);\n  }\n\n  splitText(text: string): Document[] {\n    const sections = this.splitHtmlByHeaders(text);\n\n    return sections.map(\n      section =>\n        new Document({\n          text: section.content,\n          metadata: {\n            [this.headersToSplitOn[section.tagName.toLowerCase()]!]: section.header,\n            xpath: section.xpath,\n          },\n        }),\n    );\n  }\n\n  private getXPath(element: any): string {\n    const parts: string[] = [];\n    let current = element;\n\n    while (current && current.nodeType === 1) {\n      let index = 1;\n      let sibling = current.previousSibling;\n\n      while (sibling) {\n        if (sibling.nodeType === 1 && sibling.tagName === current.tagName) {\n          index++;\n        }\n        sibling = sibling.previousSibling;\n      }\n\n      if (current.tagName) {\n        parts.unshift(`${current.tagName.toLowerCase()}[${index}]`);\n      }\n      current = current.parentNode;\n    }\n\n    return '/' + parts.join('/');\n  }\n\n  private splitHtmlByHeaders(htmlDoc: string): Array<{\n    header: string;\n    content: string;\n    tagName: string;\n    xpath: string;\n  }> {\n    const sections: Array<{\n      header: string;\n      content: string;\n      tagName: string;\n      xpath: string;\n    }> = [];\n\n    const root = parse(htmlDoc);\n    const headers = Object.keys(this.headersToSplitOn);\n    const headerElements = root.querySelectorAll(headers.join(','));\n\n    headerElements.forEach((headerElement, index) => {\n      const header = headerElement.text?.trim() || '';\n      const tagName = headerElement.tagName;\n      const xpath = this.getXPath(headerElement);\n      let content = '';\n\n      // @ts-expect-error - nextElementSibling is not defined on type Element\n      let currentElement = headerElement.nextElementSibling;\n      const nextHeader = headerElements[index + 1];\n\n      while (currentElement && (!nextHeader || currentElement !== nextHeader)) {\n        if (currentElement.text) {\n          content += currentElement.text.trim() + ' ';\n        }\n        currentElement = currentElement.nextElementSibling;\n      }\n\n      content = content.trim();\n      sections.push({\n        header,\n        content,\n        tagName,\n        xpath,\n      });\n    });\n\n    return sections;\n  }\n\n  async splitDocuments(documents: Document[]): Promise<Document[]> {\n    const texts: string[] = [];\n    const metadatas: Record<string, any>[] = [];\n\n    for (const doc of documents) {\n      texts.push(doc.text);\n      metadatas.push(doc.metadata);\n    }\n    const results = await this.createDocuments(texts, metadatas);\n\n    return this.textSplitter.splitDocuments(results);\n  }\n\n  createDocuments(texts: string[], metadatas?: Record<string, any>[]): Document[] {\n    const _metadatas = metadatas || Array(texts.length).fill({});\n    const documents: Document[] = [];\n\n    for (let i = 0; i < texts.length; i++) {\n      const chunks = this.splitText(texts[i]!);\n      for (const chunk of chunks) {\n        const metadata = { ...(_metadatas[i] || {}) };\n\n        const chunkMetadata = chunk.metadata;\n\n        if (chunkMetadata) {\n          for (const [key, value] of Object.entries(chunkMetadata || {})) {\n            if (value === '#TITLE#') {\n              chunkMetadata[key] = metadata['Title'];\n            }\n          }\n        }\n\n        documents.push(\n          new Document({\n            text: chunk.text!,\n            metadata: { ...metadata, ...chunkMetadata },\n          }),\n        );\n      }\n    }\n\n    return documents;\n  }\n\n  transformDocuments(documents: Document[]): Document[] {\n    const texts: string[] = [];\n    const metadatas: Record<string, any>[] = [];\n\n    for (const doc of documents) {\n      texts.push(doc.text);\n      metadatas.push(doc.metadata);\n    }\n\n    return this.createDocuments(texts, metadatas);\n  }\n}\n","import { Document } from '../schema';\nimport type { JsonChunkOptions } from '../types';\n\nexport class RecursiveJsonTransformer {\n  private maxSize: number;\n  private minSize: number;\n  private ensureAscii: boolean;\n  private convertLists: boolean;\n\n  constructor({ maxSize = 2000, minSize, ensureAscii = false, convertLists = true }: JsonChunkOptions) {\n    this.maxSize = maxSize;\n    this.minSize = minSize ?? Math.max(maxSize - 200, 50);\n    this.ensureAscii = ensureAscii;\n    this.convertLists = convertLists;\n  }\n\n  private static jsonSize(data: Record<string, any>): number {\n    const seen = new WeakSet();\n\n    function getStringifiableData(obj: any): any {\n      if (obj === null || typeof obj !== 'object') {\n        return obj;\n      }\n\n      if (seen.has(obj)) {\n        return '[Circular]';\n      }\n\n      seen.add(obj);\n\n      if (Array.isArray(obj)) {\n        const safeArray = [];\n        for (const item of obj) {\n          safeArray.push(getStringifiableData(item));\n        }\n        return safeArray;\n      }\n\n      const safeObj: Record<string, any> = {};\n      for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          safeObj[key] = getStringifiableData(obj[key]);\n        }\n      }\n      return safeObj;\n    }\n\n    const stringifiable = getStringifiableData(data);\n    const jsonString = JSON.stringify(stringifiable);\n    return jsonString.length;\n  }\n\n  /**\n   * Transform JSON data while handling circular references\n   */\n  public transform(data: Record<string, any>): Record<string, any> {\n    const size = RecursiveJsonTransformer.jsonSize(data);\n\n    const seen = new WeakSet();\n\n    function createSafeCopy(obj: any): any {\n      if (obj === null || typeof obj !== 'object') {\n        return obj;\n      }\n\n      if (seen.has(obj)) {\n        return '[Circular]';\n      }\n\n      seen.add(obj);\n\n      if (Array.isArray(obj)) {\n        return obj.map(item => createSafeCopy(item));\n      }\n\n      const copy: Record<string, any> = {};\n      for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          copy[key] = createSafeCopy(obj[key]);\n        }\n      }\n      return copy;\n    }\n\n    return {\n      size,\n      data: createSafeCopy(data),\n    };\n  }\n\n  /**\n   * Set a value in a nested dictionary based on the given path\n   */\n  private static setNestedDict(d: Record<string, any>, path: string[], value: any): void {\n    let current = d;\n    for (const key of path.slice(0, -1)) {\n      current[key] = current[key] || {};\n      current = current[key];\n    }\n    current[path[path.length - 1]!] = value;\n  }\n\n  /**\n   * Convert lists in the JSON structure to dictionaries with index-based keys\n   */\n  private listToDictPreprocessing(data: any): any {\n    if (data && typeof data === 'object') {\n      if (Array.isArray(data)) {\n        return Object.fromEntries(data.map((item, index) => [String(index), this.listToDictPreprocessing(item)]));\n      }\n      return Object.fromEntries(Object.entries(data).map(([k, v]) => [k, this.listToDictPreprocessing(v)]));\n    }\n    return data;\n  }\n\n  /**\n   * Handles primitive values (strings, numbers, etc) by either adding them to the current chunk\n   * or creating new chunks if they don't fit\n   */\n  private handlePrimitiveValue(\n    value: any,\n    key: string,\n    currentChunk: Record<string, any>,\n    chunks: Record<string, any>[],\n    fullPath: string[],\n  ): { currentChunk: Record<string, any>; chunks: Record<string, any>[] } {\n    const testValue = { [key]: value };\n\n    if (RecursiveJsonTransformer.jsonSize(testValue) <= this.maxSize) {\n      if (RecursiveJsonTransformer.jsonSize({ ...currentChunk, ...testValue }) <= this.maxSize) {\n        return {\n          currentChunk: { ...currentChunk, ...testValue },\n          chunks,\n        };\n      } else {\n        return {\n          currentChunk: testValue,\n          chunks: [...chunks, currentChunk],\n        };\n      }\n    } else if (typeof value === 'string') {\n      const stringChunks = this.splitLongString(value);\n      const newChunks = stringChunks\n        .map(chunk => {\n          return this.createChunk(chunk, fullPath);\n        })\n        .filter(chunk => RecursiveJsonTransformer.jsonSize(chunk) <= this.maxSize);\n\n      return {\n        currentChunk,\n        chunks: [...chunks, ...newChunks],\n      };\n    }\n\n    const newChunk = this.createChunk(value, fullPath);\n    return {\n      currentChunk,\n      chunks: RecursiveJsonTransformer.jsonSize(newChunk) <= this.maxSize ? [...chunks, newChunk] : chunks,\n    };\n  }\n\n  /**\n   * Creates a nested dictionary chunk from a value and path\n   * e.g., path ['a', 'b'], value 'c' becomes { a: { b: 'c' } }\n   */\n  private createChunk(value: any, path: string[]): Record<string, any> {\n    const chunk: Record<string, any> = {};\n    RecursiveJsonTransformer.setNestedDict(chunk, path, value);\n    return chunk.root ? chunk.root : chunk;\n  }\n\n  /**\n   * Checks if value is within size limits\n   */\n  private isWithinSizeLimit(value: any, currentSize: number = 0): boolean {\n    const size = RecursiveJsonTransformer.jsonSize(value);\n    // If this is a new chunk (currentSize = 0), allow items smaller than maxSize\n    // If adding to existing chunk, ensure total size doesn't exceed maxSize\n    return currentSize === 0 ? size <= this.maxSize : size + currentSize <= this.maxSize;\n  }\n\n  /**\n   * Splits arrays into chunks based on size limits\n   * Handles nested objects by recursing into handleNestedObject\n   */\n  private handleArray(\n    value: any[],\n    key: string,\n    currentPath: string[],\n    depth: number,\n    maxDepth: number,\n  ): Record<string, any>[] {\n    const path = currentPath.length ? [...currentPath, key] : ['root', key];\n\n    // Try keeping array intact\n    const chunk = this.createChunk(value, path);\n    if (this.isWithinSizeLimit(chunk)) {\n      return [chunk];\n    }\n\n    const chunks: Record<string, any>[] = [];\n    let currentGroup: any[] = [];\n\n    const saveCurrentGroup = () => {\n      if (currentGroup.length > 0) {\n        const groupChunk = this.createChunk(currentGroup, path);\n        if (RecursiveJsonTransformer.jsonSize(groupChunk) >= this.minSize) {\n          chunks.push(groupChunk);\n          currentGroup = [];\n        }\n      }\n    };\n\n    for (const item of value) {\n      // Try adding item to current group\n      const testGroup = [...currentGroup, item];\n      const testChunk = this.createChunk(testGroup, path);\n\n      if (this.isWithinSizeLimit(testChunk)) {\n        currentGroup = testGroup;\n        continue;\n      }\n\n      // Current group is full\n      saveCurrentGroup();\n\n      // Handle the new item\n      if (typeof item === 'object' && item !== null) {\n        const singleItemArray = [item];\n        const singleItemChunk = this.createChunk(singleItemArray, path);\n\n        if (this.isWithinSizeLimit(singleItemChunk)) {\n          currentGroup = singleItemArray;\n        } else {\n          const itemPath = [...path, String(chunks.length)];\n          const nestedChunks = this.handleNestedObject(item, itemPath, depth + 1, maxDepth);\n          chunks.push(...nestedChunks);\n        }\n      } else {\n        currentGroup = [item];\n      }\n    }\n\n    saveCurrentGroup();\n    return chunks;\n  }\n\n  /**\n   * Splits objects into chunks based on size limits\n   * Handles nested arrays and objects by recursing into handleArray and handleNestedObject\n   */\n  private handleNestedObject(\n    value: Record<string, any>,\n    fullPath: string[],\n    depth: number,\n    maxDepth: number,\n  ): Record<string, any>[] {\n    const path = fullPath.length ? fullPath : ['root'];\n\n    // Handle max depth\n    if (depth > maxDepth) {\n      console.warn(`Maximum depth of ${maxDepth} exceeded, flattening remaining structure`);\n      return [this.createChunk(value, path)];\n    }\n\n    // Try keeping object intact\n    const wholeChunk = this.createChunk(value, path);\n    if (this.isWithinSizeLimit(wholeChunk)) {\n      return [wholeChunk];\n    }\n\n    const chunks: Record<string, any>[] = [];\n    let currentChunk: Record<string, any> = {};\n\n    const saveCurrentChunk = () => {\n      if (Object.keys(currentChunk).length > 0) {\n        const objChunk = this.createChunk(currentChunk, path);\n        if (RecursiveJsonTransformer.jsonSize(objChunk) >= this.minSize) {\n          chunks.push(objChunk);\n          currentChunk = {};\n        }\n      }\n    };\n\n    for (const [key, val] of Object.entries(value)) {\n      if (val === undefined) continue;\n\n      // Handle arrays separately\n      if (Array.isArray(val)) {\n        saveCurrentChunk();\n        const arrayChunks = this.handleArray(val, key, path, depth, maxDepth);\n        chunks.push(...arrayChunks);\n        continue;\n      }\n\n      // Try adding to current chunk\n      const testChunk = this.createChunk({ ...currentChunk, [key]: val }, path);\n      if (this.isWithinSizeLimit(testChunk)) {\n        currentChunk[key] = val;\n        continue;\n      }\n\n      // Current chunk is full\n      saveCurrentChunk();\n\n      // Handle value that didn't fit\n      if (typeof val === 'object' && val !== null) {\n        const nestedChunks = this.handleNestedObject(val, [...path, key], depth + 1, maxDepth);\n        chunks.push(...nestedChunks);\n      } else {\n        currentChunk = { [key]: val };\n      }\n    }\n\n    saveCurrentChunk();\n    return chunks;\n  }\n\n  /**\n   * Splits long strings into smaller chunks at word boundaries\n   * Ensures each chunk is within maxSize limit\n   */\n  private splitLongString(value: string): string[] {\n    const chunks: string[] = [];\n    let remaining = value;\n\n    while (remaining.length > 0) {\n      const overhead = 20;\n      const chunkSize = Math.floor(this.maxSize - overhead);\n\n      if (remaining.length <= chunkSize) {\n        chunks.push(remaining);\n        break;\n      }\n\n      const lastSpace = remaining.slice(0, chunkSize).lastIndexOf(' ');\n      const splitAt = lastSpace > 0 ? lastSpace + 1 : chunkSize;\n\n      chunks.push(remaining.slice(0, splitAt));\n      remaining = remaining.slice(splitAt);\n    }\n\n    return chunks;\n  }\n\n  /**\n   * Core chunking logic that processes JSON data recursively\n   * Handles arrays, objects, and primitive values while maintaining structure\n   */\n  private jsonSplit({\n    data,\n    currentPath = [],\n    chunks = [{}],\n    depth = 0,\n    maxDepth = 100,\n  }: {\n    data: Record<string, any>;\n    currentPath?: string[];\n    chunks?: Record<string, any>[];\n    depth?: number;\n    maxDepth?: number;\n  }): Record<string, any>[] {\n    if (!data || typeof data !== 'object') {\n      return chunks;\n    }\n\n    if (depth > maxDepth) {\n      console.warn(`Maximum depth of ${maxDepth} exceeded, flattening remaining structure`);\n      RecursiveJsonTransformer.setNestedDict(chunks[chunks.length - 1] || {}, currentPath, data);\n      return chunks;\n    }\n\n    let currentChunk = {};\n    let accumulatedChunks = chunks;\n\n    for (const [key, value] of Object.entries(data)) {\n      const fullPath = [...currentPath, key];\n\n      if (Array.isArray(value)) {\n        const arrayChunks = this.handleArray(value, key, currentPath, depth, maxDepth);\n        accumulatedChunks = [...accumulatedChunks, ...arrayChunks];\n      } else if (typeof value === 'object' && value !== null) {\n        const objectChunks = this.handleNestedObject(value, fullPath, depth, maxDepth);\n        accumulatedChunks = [...accumulatedChunks, ...objectChunks];\n      } else {\n        const { currentChunk: newCurrentChunk, chunks: newChunks } = this.handlePrimitiveValue(\n          value,\n          key,\n          currentChunk,\n          accumulatedChunks,\n          fullPath,\n        );\n        currentChunk = newCurrentChunk;\n        accumulatedChunks = newChunks;\n      }\n    }\n\n    if (Object.keys(currentChunk).length > 0) {\n      accumulatedChunks = [...accumulatedChunks, currentChunk];\n    }\n\n    return accumulatedChunks.filter(chunk => Object.keys(chunk).length > 0);\n  }\n\n  /**\n   * Splits JSON into a list of JSON chunks\n   */\n  splitJson({\n    jsonData,\n    convertLists = false,\n  }: {\n    jsonData: Record<string, any>;\n    convertLists?: boolean;\n  }): Record<string, any>[] {\n    const processedData = convertLists ? this.listToDictPreprocessing(jsonData) : jsonData;\n\n    const chunks = this.jsonSplit({ data: processedData });\n\n    if (Object.keys(chunks[chunks.length - 1] || {}).length === 0) {\n      chunks.pop();\n    }\n\n    return chunks;\n  }\n\n  /**\n   * Converts Unicode characters to their escaped ASCII representation\n   * e.g., 'caf' becomes 'caf\\u00e9'\n   */\n  private escapeNonAscii(obj: any): any {\n    if (typeof obj === 'string') {\n      return obj.replace(/[\\u0080-\\uffff]/g, char => {\n        return `\\\\u${char.charCodeAt(0).toString(16).padStart(4, '0')}`;\n      });\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(item => this.escapeNonAscii(item));\n    }\n\n    if (typeof obj === 'object' && obj !== null) {\n      return Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, this.escapeNonAscii(value)]));\n    }\n\n    return obj;\n  }\n  /**\n   * Splits JSON into a list of JSON formatted strings\n   */\n  splitText({\n    jsonData,\n    convertLists = false,\n    ensureAscii = true,\n  }: {\n    jsonData: Record<string, any>;\n    convertLists?: boolean;\n    ensureAscii?: boolean;\n  }): string[] {\n    const chunks = this.splitJson({ jsonData, convertLists });\n\n    if (ensureAscii) {\n      const escapedChunks = chunks.map(chunk => this.escapeNonAscii(chunk));\n      return escapedChunks.map(chunk => JSON.stringify(chunk));\n    }\n\n    return chunks.map(chunk =>\n      JSON.stringify(chunk, (key, value) => {\n        // Convert escaped Unicode sequences back to actual characters\n        // e.g., '\\u00e9' -> ''\n        if (typeof value === 'string') {\n          return value.replace(/\\\\u[\\da-f]{4}/gi, match => String.fromCharCode(parseInt(match.slice(2), 16)));\n        }\n        return value;\n      }),\n    );\n  }\n\n  /**\n   * Create documents from a list of json objects\n   */\n  createDocuments({\n    texts,\n    convertLists = false,\n    ensureAscii = true,\n    metadatas,\n  }: {\n    texts: string[];\n    convertLists?: boolean;\n    ensureAscii?: boolean;\n    metadatas?: Record<string, any>[];\n  }): Document[] {\n    const _metadatas = metadatas || Array(texts.length).fill({});\n    const documents: Document[] = [];\n\n    texts.forEach((text, i) => {\n      const chunks = this.splitText({ jsonData: JSON.parse(text), convertLists, ensureAscii });\n      chunks.forEach(chunk => {\n        const metadata = { ...(_metadatas[i] || {}) };\n        documents.push(\n          new Document({\n            text: chunk,\n            metadata,\n          }),\n        );\n      });\n    });\n\n    return documents;\n  }\n\n  transformDocuments({\n    ensureAscii,\n    documents,\n    convertLists,\n  }: {\n    ensureAscii?: boolean;\n    convertLists?: boolean;\n    documents: Document[];\n  }): Document[] {\n    const texts: string[] = [];\n    const metadatas: Record<string, any>[] = [];\n\n    for (const doc of documents) {\n      texts.push(doc.text);\n      metadatas.push(doc.metadata);\n    }\n\n    return this.createDocuments({\n      texts,\n      metadatas,\n\n      ensureAscii,\n      convertLists,\n    });\n  }\n}\n","import { Language } from '../types';\nimport type { BaseChunkOptions } from '../types';\n\nimport { RecursiveCharacterTransformer } from './character';\n\nexport class LatexTransformer extends RecursiveCharacterTransformer {\n  constructor(options: BaseChunkOptions = {}) {\n    const separators = RecursiveCharacterTransformer.getSeparatorsForLanguage(Language.LATEX);\n    super({ ...options, separators, isSeparatorRegex: true });\n  }\n}\n","import { Document } from '../schema';\n\nimport { Language } from '../types';\nimport type { BaseChunkOptions } from '../types';\n\nimport { RecursiveCharacterTransformer } from './character';\n\ninterface LineType {\n  metadata: Record<string, string>;\n  content: string;\n}\n\ninterface HeaderType {\n  level: number;\n  name: string;\n  data: string;\n}\n\nexport class MarkdownTransformer extends RecursiveCharacterTransformer {\n  constructor(options: BaseChunkOptions = {}) {\n    const separators = RecursiveCharacterTransformer.getSeparatorsForLanguage(Language.MARKDOWN);\n    super({ ...options, separators, isSeparatorRegex: true });\n  }\n}\n\nexport class MarkdownHeaderTransformer {\n  private headersToSplitOn: [string, string][];\n  private returnEachLine: boolean;\n  private stripHeaders: boolean;\n\n  constructor(headersToSplitOn: [string, string][], returnEachLine: boolean = false, stripHeaders: boolean = true) {\n    this.headersToSplitOn = [...headersToSplitOn].sort((a, b) => b[0].length - a[0].length);\n    this.returnEachLine = returnEachLine;\n    this.stripHeaders = stripHeaders;\n  }\n\n  private aggregateLinesToChunks(lines: LineType[]): Document[] {\n    if (this.returnEachLine) {\n      return lines.flatMap(line => {\n        const contentLines = line.content.split('\\n');\n        return contentLines\n          .filter(l => l.trim() !== '' || this.headersToSplitOn.some(([sep]) => l.trim().startsWith(sep)))\n          .map(\n            l =>\n              new Document({\n                text: l.trim(),\n                metadata: line.metadata,\n              }),\n          );\n      });\n    }\n\n    const aggregatedChunks: LineType[] = [];\n\n    for (const line of lines) {\n      const lastLine = aggregatedChunks[aggregatedChunks.length - 1]?.content?.split('\\n')?.slice(-1)[0]?.trim();\n      const lastChunkIsHeader = lastLine ? this.headersToSplitOn.some(([sep]) => lastLine.startsWith(sep)) : false;\n      if (\n        aggregatedChunks.length > 0 &&\n        JSON.stringify(aggregatedChunks?.[aggregatedChunks.length - 1]!.metadata) === JSON.stringify(line.metadata)\n      ) {\n        const aggChunk = aggregatedChunks[aggregatedChunks.length - 1];\n        aggChunk!.content += '  \\n' + line.content;\n      } else if (\n        aggregatedChunks.length > 0 &&\n        JSON.stringify(aggregatedChunks?.[aggregatedChunks.length - 1]!.metadata) !== JSON.stringify(line.metadata) &&\n        Object.keys(aggregatedChunks?.[aggregatedChunks.length - 1]!.metadata).length <\n          Object.keys(line.metadata).length &&\n        lastChunkIsHeader\n      ) {\n        if (aggregatedChunks && aggregatedChunks?.[aggregatedChunks.length - 1]) {\n          const aggChunk = aggregatedChunks[aggregatedChunks.length - 1];\n          if (aggChunk) {\n            aggChunk.content += '  \\n' + line.content;\n            aggChunk.metadata = line.metadata;\n          }\n        }\n      } else {\n        aggregatedChunks.push(line);\n      }\n    }\n\n    return aggregatedChunks.map(\n      chunk =>\n        new Document({\n          text: chunk.content,\n          metadata: chunk.metadata,\n        }),\n    );\n  }\n\n  splitText({ text }: { text: string }): Document[] {\n    const lines = text.split('\\n');\n    const linesWithMetadata: LineType[] = [];\n    let currentContent: string[] = [];\n    let currentMetadata: Record<string, string> = {};\n    const headerStack: HeaderType[] = [];\n    const initialMetadata: Record<string, string> = {};\n\n    let inCodeBlock = false;\n    let openingFence = '';\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i]!;\n      const strippedLine = line.trim();\n\n      if (!inCodeBlock) {\n        if (\n          (strippedLine.startsWith('```') && strippedLine.split('```').length === 2) ||\n          strippedLine.startsWith('~~~')\n        ) {\n          inCodeBlock = true;\n          openingFence = strippedLine.startsWith('```') ? '```' : '~~~';\n        }\n      } else {\n        if (strippedLine.startsWith(openingFence)) {\n          inCodeBlock = false;\n          openingFence = '';\n        }\n      }\n\n      if (inCodeBlock) {\n        currentContent.push(line);\n        continue;\n      }\n\n      let headerMatched = false;\n      for (const [sep, name] of this.headersToSplitOn) {\n        if (strippedLine.startsWith(sep) && (strippedLine.length === sep.length || strippedLine[sep.length] === ' ')) {\n          headerMatched = true;\n\n          // If we have existing content, save it before processing the header\n          if (currentContent.length > 0) {\n            linesWithMetadata.push({\n              content: currentContent.join('\\n'),\n              metadata: { ...currentMetadata },\n            });\n            currentContent = [];\n          }\n\n          if (name !== null) {\n            const currentHeaderLevel = (sep.match(/#/g) || []).length;\n\n            // Pop headers of lower or same level\n            while (headerStack.length > 0 && headerStack?.[headerStack.length - 1]!.level >= currentHeaderLevel) {\n              const poppedHeader = headerStack.pop()!;\n              if (poppedHeader.name in initialMetadata) {\n                delete initialMetadata[poppedHeader.name];\n              }\n            }\n\n            // Push current header\n            const header: HeaderType = {\n              level: currentHeaderLevel,\n              name,\n              data: strippedLine.slice(sep.length).trim(),\n            };\n            headerStack.push(header);\n            initialMetadata[name] = header.data;\n          }\n\n          // Only add header to linesWithMetadata if stripHeaders is false\n          if (!this.stripHeaders) {\n            linesWithMetadata.push({\n              content: line,\n              metadata: { ...currentMetadata, ...initialMetadata },\n            });\n          }\n          break;\n        }\n      }\n\n      if (!headerMatched) {\n        if (strippedLine || this.returnEachLine) {\n          currentContent.push(line);\n\n          if (this.returnEachLine) {\n            // In returnEachLine mode, flush each non-header line immediately\n            linesWithMetadata.push({\n              content: line,\n              metadata: { ...currentMetadata },\n            });\n            currentContent = [];\n          }\n        } else if (currentContent.length > 0) {\n          linesWithMetadata.push({\n            content: currentContent.join('\\n'),\n            metadata: { ...currentMetadata },\n          });\n          currentContent = [];\n        }\n      }\n\n      // Reset metadata for next line\n      currentMetadata = { ...initialMetadata };\n    }\n\n    // Handle any remaining content\n    if (currentContent.length > 0) {\n      linesWithMetadata.push({\n        content: currentContent.join('\\n'),\n        metadata: currentMetadata,\n      });\n    }\n\n    return this.aggregateLinesToChunks(linesWithMetadata);\n  }\n\n  createDocuments(texts: string[], metadatas?: Record<string, any>[]): Document[] {\n    const _metadatas = metadatas || Array(texts.length).fill({});\n    const documents: Document[] = [];\n\n    texts.forEach((text, i) => {\n      this.splitText({ text }).forEach(chunk => {\n        const metadata = { ..._metadatas[i], ...chunk.metadata };\n        documents.push(\n          new Document({\n            text: chunk.text,\n            metadata,\n          }),\n        );\n      });\n    });\n\n    return documents;\n  }\n\n  transformDocuments(documents: Document[]): Document[] {\n    const texts: string[] = [];\n    const metadatas: Record<string, any>[] = [];\n\n    for (const doc of documents) {\n      texts.push(doc.text);\n      metadatas.push(doc.metadata);\n    }\n\n    return this.createDocuments(texts, metadatas);\n  }\n}\n","import type { TiktokenModel, TiktokenEncoding, Tiktoken } from 'js-tiktoken';\nimport { encodingForModel, getEncoding } from 'js-tiktoken';\nimport { Document } from '../schema';\nimport type { SemanticMarkdownChunkOptions } from '../types';\n\nimport { TextTransformer } from './text';\n\ninterface MarkdownNode {\n  title: string;\n  depth: number;\n  content: string;\n  length: number;\n}\n\nexport class SemanticMarkdownTransformer extends TextTransformer {\n  private tokenizer: Tiktoken;\n  private joinThreshold: number;\n  private allowedSpecial: Set<string> | 'all';\n  private disallowedSpecial: Set<string> | 'all';\n\n  constructor({\n    joinThreshold = 500,\n    encodingName = 'cl100k_base',\n    modelName,\n    allowedSpecial = new Set(),\n    disallowedSpecial = 'all',\n    ...baseOptions\n  }: SemanticMarkdownChunkOptions = {}) {\n    super(baseOptions);\n\n    this.joinThreshold = joinThreshold;\n    this.allowedSpecial = allowedSpecial;\n    this.disallowedSpecial = disallowedSpecial;\n\n    try {\n      this.tokenizer = modelName ? encodingForModel(modelName) : getEncoding(encodingName);\n    } catch {\n      throw new Error('Could not load tiktoken encoding. Please install it with `npm install js-tiktoken`.');\n    }\n  }\n\n  private countTokens(text: string): number {\n    const allowed = this.allowedSpecial === 'all' ? 'all' : Array.from(this.allowedSpecial);\n    const disallowed = this.disallowedSpecial === 'all' ? 'all' : Array.from(this.disallowedSpecial);\n\n    const processedText = this.stripWhitespace ? text.trim() : text;\n    return this.tokenizer.encode(processedText, allowed, disallowed).length;\n  }\n\n  private splitMarkdownByHeaders(markdown: string): MarkdownNode[] {\n    const sections: MarkdownNode[] = [];\n    const lines = markdown.split('\\n');\n    let currentContent = '';\n    let currentTitle = '';\n    let currentDepth = 0;\n    let inCodeBlock = false;\n\n    const headerRegex = /^(#+)\\s+(.+)$/;\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i]!;\n      const headerMatch = line.match(headerRegex);\n\n      // Track code blocks to avoid parsing headers inside them\n      if (line.startsWith('```') || line.startsWith('~~~')) {\n        inCodeBlock = !inCodeBlock;\n      }\n\n      if (headerMatch && !inCodeBlock) {\n        // Save previous section\n        // Push the previous section if it has content or if it's a header.\n        // This ensures headers that only act as parents are not lost.\n        if (currentContent.trim() !== '' || (currentTitle && currentDepth > 0)) {\n          sections.push({\n            title: currentTitle,\n            content: currentContent.trim(),\n            depth: currentDepth,\n            length: this.countTokens(currentContent.trim()),\n          });\n        }\n        currentContent = ''; // Always reset for the new section\n\n        // Start new section\n        currentDepth = headerMatch[1]!.length;\n        currentTitle = headerMatch[2]!;\n      } else {\n        currentContent += line + '\\n';\n      }\n    }\n\n    // Add the last section\n    if (currentContent.trim() !== '') {\n      sections.push({\n        title: currentTitle,\n        content: currentContent.trim(),\n        depth: currentDepth,\n        length: this.countTokens(currentContent.trim()),\n      });\n    }\n\n    // Remove initial empty preamble if present, but keep non-empty preambles\n    if (sections.length > 1 && sections[0]!.title === '' && sections[0]!.content.trim() === '') {\n      sections.shift();\n    }\n\n    return sections;\n  }\n\n  private mergeSemanticSections(sections: MarkdownNode[]): MarkdownNode[] {\n    if (sections.length === 0) return sections;\n\n    const workingSections = [...sections];\n    const deepest = Math.max(...workingSections.map(s => s.depth));\n\n    for (let depth = deepest; depth > 0; depth--) {\n      for (let j = 1; j < workingSections.length; j++) {\n        const current = workingSections[j]!;\n\n        if (current.depth === depth) {\n          const prev = workingSections[j - 1]!;\n\n          if (prev.length + current.length < this.joinThreshold && prev.depth <= current.depth) {\n            const title = `${'#'.repeat(current.depth)} ${current.title}`;\n            const formattedTitle = `\\n\\n${title}`;\n\n            prev.content += `${formattedTitle}\\n${current.content}`;\n\n            prev.length = this.countTokens(prev.content);\n\n            workingSections.splice(j, 1);\n            j--;\n          }\n        }\n      }\n    }\n\n    return workingSections;\n  }\n\n  splitText({ text }: { text: string }): string[] {\n    if (!text.trim()) return [];\n\n    const initialSections = this.splitMarkdownByHeaders(text);\n\n    const mergedSections = this.mergeSemanticSections(initialSections);\n\n    return mergedSections.map(section => {\n      if (section.title) {\n        const header = `${'#'.repeat(section.depth)} ${section.title}`;\n        return `${header}\\n${section.content}`;\n      }\n      return section.content;\n    });\n  }\n\n  createDocuments(texts: string[], metadatas?: Record<string, any>[]): Document[] {\n    const _metadatas = metadatas || Array(texts.length).fill({});\n    const documents: Document[] = [];\n\n    texts.forEach((text, i) => {\n      this.splitText({ text }).forEach(chunk => {\n        const metadata = {\n          ..._metadatas[i],\n          tokenCount: this.countTokens(chunk),\n        };\n\n        documents.push(\n          new Document({\n            text: chunk,\n            metadata,\n          }),\n        );\n      });\n    });\n\n    return documents;\n  }\n\n  transformDocuments(documents: Document[]): Document[] {\n    const texts: string[] = [];\n    const metadatas: Record<string, any>[] = [];\n\n    for (const doc of documents) {\n      texts.push(doc.text);\n      metadatas.push(doc.metadata);\n    }\n\n    return this.createDocuments(texts, metadatas);\n  }\n\n  static fromTikToken({\n    encodingName = 'cl100k_base',\n    modelName,\n    options = {},\n  }: {\n    encodingName?: TiktokenEncoding;\n    modelName?: TiktokenModel;\n    options?: SemanticMarkdownChunkOptions;\n  }): SemanticMarkdownTransformer {\n    let tokenizer: Tiktoken;\n\n    try {\n      tokenizer = modelName ? encodingForModel(modelName) : getEncoding(encodingName);\n    } catch {\n      throw new Error('Could not load tiktoken encoding. Please install it with `npm install js-tiktoken`.');\n    }\n\n    const tikTokenCounter = (text: string): number => {\n      const allowed =\n        options.allowedSpecial === 'all' ? 'all' : options.allowedSpecial ? Array.from(options.allowedSpecial) : [];\n      const disallowed =\n        options.disallowedSpecial === 'all'\n          ? 'all'\n          : options.disallowedSpecial\n            ? Array.from(options.disallowedSpecial)\n            : [];\n      return tokenizer.encode(text, allowed, disallowed).length;\n    };\n\n    return new SemanticMarkdownTransformer({\n      ...options,\n      encodingName,\n      modelName,\n      lengthFunction: tikTokenCounter,\n    });\n  }\n}\n","import type { SentenceChunkOptions } from '../types';\nimport { TextTransformer } from './text';\n\nexport class SentenceTransformer extends TextTransformer {\n  protected minSize: number;\n  protected maxSize: number;\n  protected targetSize: number;\n  protected sentenceEnders: string[];\n  protected fallbackToWords: boolean;\n  protected fallbackToCharacters: boolean;\n  protected keepSeparator: boolean | 'start' | 'end';\n\n  constructor(options: SentenceChunkOptions) {\n    // Ensure overlap doesn't exceed maxSize for parent validation\n    const parentOverlap = Math.min(options.overlap ?? 0, options.maxSize - 1);\n\n    const baseOptions = {\n      ...options,\n      overlap: parentOverlap, // Use adjusted overlap for parent\n    };\n\n    super(baseOptions);\n\n    this.maxSize = options.maxSize;\n    this.minSize = options.minSize ?? 50;\n    this.targetSize = options.targetSize ?? Math.floor(options.maxSize * 0.8);\n    this.sentenceEnders = options.sentenceEnders ?? ['.', '!', '?'];\n    this.fallbackToWords = options.fallbackToWords ?? true;\n    this.fallbackToCharacters = options.fallbackToCharacters ?? true;\n    this.keepSeparator = options.keepSeparator ?? false;\n\n    // Override with original overlap for our sentence logic\n    this.overlap = options.overlap ?? 0;\n  }\n\n  private detectSentenceBoundaries(text: string): string[] {\n    if (!text) return [];\n\n    const sentences: string[] = [];\n    let currentSentence = '';\n    let i = 0;\n\n    while (i < text.length) {\n      const char = text[i];\n      if (!char) break; // Safety check\n\n      currentSentence += char;\n\n      if (this.sentenceEnders.includes(char)) {\n        const remainingText = text.slice(i + 1);\n\n        if (this.isRealSentenceBoundary(currentSentence, remainingText)) {\n          sentences.push(currentSentence.trim());\n          currentSentence = '';\n        }\n      }\n      i++;\n    }\n\n    if (currentSentence.trim()) {\n      sentences.push(currentSentence.trim());\n    }\n\n    return sentences.filter(s => s.length > 0);\n  }\n\n  private isRealSentenceBoundary(currentSentence: string, remainingText: string): boolean {\n    if (!remainingText.trim()) {\n      return true;\n    }\n\n    if (!/^\\s+[A-Z]/.test(remainingText)) {\n      return false;\n    }\n\n    const words = currentSentence.trim().split(/\\s+/);\n    const lastWord = words[words.length - 1] || '';\n\n    const baseWord = lastWord.slice(0, -1);\n\n    if (this.isCommonAbbreviation(baseWord)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private isCommonAbbreviation(word: string): boolean {\n    // Common titles\n    const titles = ['Dr', 'Mr', 'Mrs', 'Ms', 'Prof', 'Sr', 'Jr'];\n    if (titles.includes(word)) {\n      return true;\n    }\n\n    // Multi-character abbreviations with periods (U.S.A., a.m., p.m., etc.)\n    if (/^[A-Z](\\.[A-Z])*$/.test(word) || /^[a-z](\\.[a-z])*$/.test(word)) {\n      return true;\n    }\n\n    // Single capital letters (initials)\n    if (/^[A-Z]$/.test(word)) {\n      return true;\n    }\n\n    // Numbers (versions, decimals)\n    if (/^\\d+$/.test(word)) {\n      return true;\n    }\n\n    // Time abbreviations\n    if (/^[ap]\\.?m$/i.test(word)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Group sentences into chunks with integrated overlap processing\n   */\n  private groupSentencesIntoChunks(sentences: string[]): string[] {\n    const chunks: string[] = [];\n    let currentChunk: string[] = [];\n    let currentSize = 0;\n\n    const separator = ' ';\n\n    for (const sentence of sentences) {\n      const sentenceLength = this.lengthFunction(sentence);\n      const separatorLength = currentChunk.length > 0 ? this.lengthFunction(separator) : 0;\n      const totalLength = currentSize + sentenceLength + separatorLength;\n\n      // Handle oversized sentences with fallback strategies\n      if (sentenceLength > this.maxSize) {\n        if (currentChunk.length > 0) {\n          chunks.push(currentChunk.join(separator));\n          currentChunk = [];\n          currentSize = 0;\n        }\n\n        const fallbackChunks = this.handleOversizedSentence(sentence);\n        chunks.push(...fallbackChunks);\n        continue;\n      }\n\n      // If adding this sentence would exceed maxSize, finalize current chunk\n      if (currentChunk.length > 0 && totalLength > this.maxSize) {\n        chunks.push(currentChunk.join(separator));\n\n        const overlapSentences = this.calculateSentenceOverlap(currentChunk);\n        currentChunk = overlapSentences;\n        currentSize = this.calculateChunkSize(currentChunk);\n      }\n\n      currentChunk.push(sentence);\n      currentSize += sentenceLength + separatorLength;\n\n      // If we've reached our target size, consider finalizing the chunk\n      if (currentSize >= this.targetSize) {\n        chunks.push(currentChunk.join(separator));\n\n        const overlapSentences = this.calculateSentenceOverlap(currentChunk);\n        currentChunk = overlapSentences;\n        currentSize = this.calculateChunkSize(currentChunk);\n      }\n    }\n\n    if (currentChunk.length > 0) {\n      chunks.push(currentChunk.join(separator));\n    }\n\n    return chunks;\n  }\n\n  /**\n   * Handle oversized sentences with fallback strategies\n   */\n  private handleOversizedSentence(sentence: string): string[] {\n    // First fallback\n    if (this.fallbackToWords) {\n      const wordChunks = this.splitSentenceIntoWords(sentence);\n      if (wordChunks.length > 1) {\n        return wordChunks;\n      }\n    }\n\n    // Second fallback\n    if (this.fallbackToCharacters) {\n      return this.splitSentenceIntoCharacters(sentence);\n    }\n\n    // Last resort\n    console.warn(\n      `Sentence exceeds maxSize (${this.maxSize}) and fallbacks are disabled: \"${sentence.substring(0, 50)}...\"`,\n    );\n    return [sentence];\n  }\n\n  private splitSentenceIntoWords(sentence: string): string[] {\n    const words = sentence.split(/\\s+/);\n    const chunks: string[] = [];\n    let currentChunk = '';\n\n    for (const word of words) {\n      const testChunk = currentChunk ? currentChunk + ' ' + word : word;\n\n      if (this.lengthFunction(testChunk) <= this.maxSize) {\n        currentChunk = testChunk;\n      } else {\n        if (currentChunk) {\n          chunks.push(currentChunk);\n        }\n\n        if (this.lengthFunction(word) > this.maxSize) {\n          if (this.fallbackToCharacters) {\n            chunks.push(...this.splitSentenceIntoCharacters(word));\n          } else {\n            chunks.push(word);\n          }\n          currentChunk = '';\n        } else {\n          currentChunk = word;\n        }\n      }\n    }\n\n    if (currentChunk) {\n      chunks.push(currentChunk);\n    }\n\n    return chunks;\n  }\n\n  private splitSentenceIntoCharacters(text: string): string[] {\n    const chunks: string[] = [];\n    let currentChunk = '';\n\n    for (const char of text) {\n      if (this.lengthFunction(currentChunk + char) <= this.maxSize) {\n        currentChunk += char;\n      } else {\n        if (currentChunk) {\n          chunks.push(currentChunk);\n        }\n        currentChunk = char;\n      }\n    }\n\n    if (currentChunk) {\n      chunks.push(currentChunk);\n    }\n\n    return chunks;\n  }\n\n  private calculateSentenceOverlap(currentChunk: string[]): string[] {\n    if (this.overlap === 0 || currentChunk.length === 0) {\n      return [];\n    }\n\n    const overlapSentences: string[] = [];\n    let overlapSize = 0;\n    const separator = ' ';\n\n    // Work backwards through sentences to build overlap\n    for (let i = currentChunk.length - 1; i >= 0; i--) {\n      const sentence = currentChunk[i];\n      if (!sentence) continue;\n\n      const sentenceLength = this.lengthFunction(sentence);\n      const separatorLength = overlapSentences.length > 0 ? this.lengthFunction(separator) : 0;\n\n      if (overlapSize + sentenceLength + separatorLength > this.overlap) {\n        break;\n      }\n\n      overlapSentences.unshift(sentence);\n      overlapSize += sentenceLength + separatorLength;\n    }\n\n    return overlapSentences;\n  }\n\n  private calculateChunkSize(sentences: string[]): number {\n    if (!sentences || sentences.length === 0) {\n      return 0;\n    }\n\n    let totalSize = 0;\n    const separator = ' ';\n\n    for (let i = 0; i < sentences.length; i++) {\n      const sentence = sentences[i]!;\n      totalSize += this.lengthFunction(sentence);\n\n      // Add separator length for all but the last sentence\n      if (i < sentences.length - 1) {\n        totalSize += this.lengthFunction(separator);\n      }\n    }\n\n    return totalSize;\n  }\n\n  splitText({ text }: { text: string }): string[] {\n    if (!text) return [];\n\n    const sentences = this.detectSentenceBoundaries(text);\n\n    const chunks = this.groupSentencesIntoChunks(sentences);\n\n    return chunks.filter(chunk => chunk.trim().length > 0);\n  }\n}\n","import type { TiktokenModel, TiktokenEncoding, Tiktoken } from 'js-tiktoken';\nimport { encodingForModel, getEncoding } from 'js-tiktoken';\nimport type { TokenChunkOptions } from '../types';\n\nimport { TextTransformer } from './text';\n\ninterface Tokenizer {\n  overlap: number;\n  tokensPerChunk: number;\n  decode: (tokens: number[]) => string;\n  encode: (text: string) => number[];\n}\n\nexport function splitTextOnTokens({ text, tokenizer }: { text: string; tokenizer: Tokenizer }): string[] {\n  const splits: string[] = [];\n  const inputIds = tokenizer.encode(text);\n  let startIdx = 0;\n  let curIdx = Math.min(startIdx + tokenizer.tokensPerChunk, inputIds.length);\n  let chunkIds = inputIds.slice(startIdx, curIdx);\n\n  while (startIdx < inputIds.length) {\n    splits.push(tokenizer.decode(chunkIds));\n    if (curIdx === inputIds.length) {\n      break;\n    }\n    startIdx += tokenizer.tokensPerChunk - tokenizer.overlap;\n    curIdx = Math.min(startIdx + tokenizer.tokensPerChunk, inputIds.length);\n    chunkIds = inputIds.slice(startIdx, curIdx);\n  }\n\n  return splits;\n}\n\nexport class TokenTransformer extends TextTransformer {\n  private tokenizer: Tiktoken;\n  private allowedSpecial: Set<string> | 'all';\n  private disallowedSpecial: Set<string> | 'all';\n\n  constructor({\n    encodingName = 'cl100k_base',\n    modelName,\n    allowedSpecial = new Set(),\n    disallowedSpecial = 'all',\n    options = {},\n  }: {\n    encodingName?: TiktokenEncoding;\n    modelName?: TiktokenModel;\n    allowedSpecial?: Set<string> | 'all';\n    disallowedSpecial?: Set<string> | 'all';\n    options: TokenChunkOptions;\n  }) {\n    super(options);\n\n    try {\n      this.tokenizer = modelName ? encodingForModel(modelName) : getEncoding(encodingName);\n    } catch {\n      throw new Error('Could not load tiktoken encoding. ' + 'Please install it with `npm install js-tiktoken`.');\n    }\n\n    this.allowedSpecial = allowedSpecial;\n    this.disallowedSpecial = disallowedSpecial;\n  }\n\n  splitText({ text }: { text: string }): string[] {\n    const encode = (text: string): number[] => {\n      const allowed = this.allowedSpecial === 'all' ? 'all' : Array.from(this.allowedSpecial);\n\n      const disallowed = this.disallowedSpecial === 'all' ? 'all' : Array.from(this.disallowedSpecial);\n\n      // If stripWhitespace is enabled, trim the text before encoding\n      const processedText = this.stripWhitespace ? text.trim() : text;\n      return Array.from(this.tokenizer.encode(processedText, allowed, disallowed));\n    };\n\n    const decode = (tokens: number[]): string => {\n      const text = this.tokenizer.decode(tokens);\n      return this.stripWhitespace ? text.trim() : text;\n    };\n\n    const tokenizer: Tokenizer = {\n      overlap: this.overlap,\n      tokensPerChunk: this.maxSize,\n      decode,\n      encode,\n    };\n\n    return splitTextOnTokens({ text, tokenizer });\n  }\n\n  static fromTikToken({\n    encodingName = 'cl100k_base',\n    modelName,\n    options = {},\n  }: {\n    encodingName?: TiktokenEncoding;\n    modelName?: TiktokenModel;\n    options?: TokenChunkOptions;\n  }): TokenTransformer {\n    let tokenizer: Tiktoken;\n\n    try {\n      if (modelName) {\n        tokenizer = encodingForModel(modelName);\n      } else {\n        tokenizer = getEncoding(encodingName);\n      }\n    } catch {\n      throw new Error('Could not load tiktoken encoding. ' + 'Please install it with `npm install js-tiktoken`.');\n    }\n\n    const tikTokenEncoder = (text: string): number => {\n      const allowed =\n        options.allowedSpecial === 'all' ? 'all' : options.allowedSpecial ? Array.from(options.allowedSpecial) : [];\n\n      const disallowed =\n        options.disallowedSpecial === 'all'\n          ? 'all'\n          : options.disallowedSpecial\n            ? Array.from(options.disallowedSpecial)\n            : [];\n\n      return tokenizer.encode(text, allowed, disallowed).length;\n    };\n\n    return new TokenTransformer({\n      encodingName,\n      modelName,\n      allowedSpecial: options.allowedSpecial,\n      disallowedSpecial: options.disallowedSpecial,\n      options: {\n        maxSize: options.maxSize,\n        overlap: options.overlap,\n        lengthFunction: tikTokenEncoder,\n      },\n    });\n  }\n}\n","import { z } from 'zod';\nimport type { ChunkStrategy } from './types';\n\nfunction handleDeprecatedSize<T extends { size?: number; maxSize?: number }>(data: T): Omit<T, 'size'> {\n  if (data.size !== undefined) {\n    console.warn(\n      '[DEPRECATION] `size` is deprecated. Use `maxSize` instead. This will be removed in the next major version.',\n    );\n\n    if (data.maxSize === undefined) {\n      data.maxSize = data.size;\n    }\n  }\n\n  const { size, ...rest } = data;\n  return rest;\n}\n\n// Base options that apply to all strategies\nconst baseChunkOptionsSchema = z.object({\n  size: z.number().positive().optional(),\n  maxSize: z.number().positive().optional(),\n  overlap: z.number().min(0).optional(),\n  lengthFunction: z.function().optional(),\n  keepSeparator: z.union([z.boolean(), z.literal('start'), z.literal('end')]).optional(),\n  addStartIndex: z.boolean().optional(),\n  stripWhitespace: z.boolean().optional(),\n});\n\n// Strategy-specific schemas\nconst characterChunkOptionsSchema = baseChunkOptionsSchema\n  .extend({\n    separator: z.string().optional(),\n    isSeparatorRegex: z.boolean().optional(),\n  })\n  .strict();\n\nconst recursiveChunkOptionsSchema = baseChunkOptionsSchema\n  .extend({\n    separators: z.array(z.string()).optional(),\n    isSeparatorRegex: z.boolean().optional(),\n    language: z.string().optional(),\n  })\n  .strict();\n\nconst sentenceChunkOptionsSchema = baseChunkOptionsSchema\n  .extend({\n    maxSize: z.number().positive(),\n    minSize: z.number().positive().optional(),\n    targetSize: z.number().positive().optional(),\n    sentenceEnders: z.array(z.string()).optional(),\n    fallbackToWords: z.boolean().optional(),\n    fallbackToCharacters: z.boolean().optional(),\n  })\n  .strict();\n\n// Predicate to check for Set-like objects\nconst isSetLike = (value: unknown): value is Set<any> => {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof (value as Set<any>).has === 'function' &&\n    typeof (value as Set<any>).add === 'function' &&\n    typeof (value as Set<any>).delete === 'function' &&\n    typeof (value as Set<any>).clear === 'function' &&\n    typeof (value as Set<any>).size === 'number'\n  );\n};\n\n// Zod schema for a Set or the literal 'all'\nconst setOrAllSchema = z\n  .any()\n  .refine(value => value === 'all' || isSetLike(value), {\n    message: \"Must be a Set object or the literal 'all'\",\n  })\n  .optional();\n\nconst tokenChunkOptionsSchema = baseChunkOptionsSchema\n  .extend({\n    encodingName: z.string().optional(),\n    modelName: z.string().optional(),\n    allowedSpecial: setOrAllSchema,\n    disallowedSpecial: setOrAllSchema,\n  })\n  .strict();\n\nconst jsonChunkOptionsSchema = baseChunkOptionsSchema\n  .extend({\n    minSize: z.number().positive().optional(),\n    ensureAscii: z.boolean().optional(),\n    convertLists: z.boolean().optional(),\n  })\n  .strict();\n\nconst htmlChunkOptionsSchema = baseChunkOptionsSchema\n  .extend({\n    headers: z.array(z.tuple([z.string(), z.string()])).optional(),\n    sections: z.array(z.tuple([z.string(), z.string()])).optional(),\n    returnEachLine: z.boolean().optional(),\n  })\n  .strict();\n\nconst markdownChunkOptionsSchema = baseChunkOptionsSchema\n  .extend({\n    headers: z.array(z.tuple([z.string(), z.string()])).optional(),\n    returnEachLine: z.boolean().optional(),\n    stripHeaders: z.boolean().optional(),\n  })\n  .strict();\n\nconst semanticMarkdownChunkOptionsSchema = baseChunkOptionsSchema\n  .extend({\n    joinThreshold: z.number().positive().optional(),\n    encodingName: z.string().optional(),\n    modelName: z.string().optional(),\n    allowedSpecial: setOrAllSchema,\n    disallowedSpecial: setOrAllSchema,\n  })\n  .strict();\n\nconst latexChunkOptionsSchema = baseChunkOptionsSchema.strict();\n\n// Strategy-specific validation schemas\nconst validationSchemas = {\n  character: characterChunkOptionsSchema.transform(handleDeprecatedSize),\n  recursive: recursiveChunkOptionsSchema.transform(handleDeprecatedSize),\n  sentence: sentenceChunkOptionsSchema.transform(handleDeprecatedSize),\n  token: tokenChunkOptionsSchema.transform(handleDeprecatedSize),\n  json: jsonChunkOptionsSchema.transform(handleDeprecatedSize),\n  html: htmlChunkOptionsSchema.transform(handleDeprecatedSize),\n  markdown: markdownChunkOptionsSchema.transform(handleDeprecatedSize),\n  'semantic-markdown': semanticMarkdownChunkOptionsSchema.transform(handleDeprecatedSize),\n  latex: latexChunkOptionsSchema.transform(handleDeprecatedSize),\n} as const;\n\nexport function validateChunkParams(strategy: ChunkStrategy, params: any): void {\n  const schema = validationSchemas[strategy];\n  if (!schema) {\n    throw new Error(`Unknown chunking strategy: ${strategy}`);\n  }\n\n  const result = schema.safeParse(params);\n  if (!result.success) {\n    // Extract unrecognized keys for cleaner error message\n    const unrecognizedError = result.error.errors.find((e: any) => e.code === 'unrecognized_keys');\n    if (unrecognizedError && 'keys' in unrecognizedError) {\n      const keys = (unrecognizedError as any).keys.join(', ');\n      throw new Error(`Invalid parameters for ${strategy} strategy: '${keys}' not supported`);\n    }\n\n    // Fallback to general error message for other validation issues\n    const errorMessage = result.error.errors\n      .map((e: any) => `${e.path.length > 0 ? e.path.join('.') : 'parameter'}: ${e.message}`)\n      .join(', ');\n\n    throw new Error(`Invalid parameters for ${strategy} strategy: ${errorMessage}`);\n  }\n}\n","import { TitleExtractor, SummaryExtractor, QuestionsAnsweredExtractor, KeywordExtractor } from './extractors';\nimport type { BaseNode } from './schema';\nimport { Document as Chunk, NodeRelationship, ObjectType } from './schema';\n\nimport { CharacterTransformer, RecursiveCharacterTransformer } from './transformers/character';\nimport { HTMLHeaderTransformer, HTMLSectionTransformer } from './transformers/html';\nimport { RecursiveJsonTransformer } from './transformers/json';\nimport { LatexTransformer } from './transformers/latex';\nimport { MarkdownHeaderTransformer, MarkdownTransformer } from './transformers/markdown';\nimport { SemanticMarkdownTransformer } from './transformers/semantic-markdown';\nimport { SentenceTransformer } from './transformers/sentence';\nimport { TokenTransformer } from './transformers/token';\nimport type {\n  ChunkParams,\n  ChunkStrategy,\n  ExtractParams,\n  HTMLChunkOptions,\n  RecursiveChunkOptions,\n  CharacterChunkOptions,\n  TokenChunkOptions,\n  MarkdownChunkOptions,\n  SemanticMarkdownChunkOptions,\n  JsonChunkOptions,\n  LatexChunkOptions,\n  SentenceChunkOptions,\n  StrategyOptions,\n} from './types';\nimport { validateChunkParams } from './validation';\n\nexport class MDocument {\n  private chunks: Chunk[];\n  private type: string; // e.g., 'text', 'html', 'markdown', 'json'\n\n  constructor({ docs, type }: { docs: { text: string; metadata?: Record<string, any> }[]; type: string }) {\n    this.chunks = docs.map(d => {\n      return new Chunk({ text: d.text, metadata: d.metadata });\n    });\n    this.type = type;\n  }\n\n  async extractMetadata({ title, summary, questions, keywords }: ExtractParams): Promise<MDocument> {\n    const transformations = [];\n\n    if (typeof summary !== 'undefined') {\n      transformations.push(new SummaryExtractor(typeof summary === 'boolean' ? {} : summary));\n    }\n\n    if (typeof questions !== 'undefined') {\n      transformations.push(new QuestionsAnsweredExtractor(typeof questions === 'boolean' ? {} : questions));\n    }\n\n    if (typeof keywords !== 'undefined') {\n      transformations.push(new KeywordExtractor(typeof keywords === 'boolean' ? {} : keywords));\n    }\n\n    if (typeof title !== 'undefined') {\n      transformations.push(new TitleExtractor(typeof title === 'boolean' ? {} : title));\n      this.chunks = this.chunks.map(doc =>\n        doc?.metadata?.docId\n          ? new Chunk({\n              ...doc,\n              relationships: {\n                [NodeRelationship.SOURCE]: {\n                  nodeId: doc.metadata.docId,\n                  nodeType: ObjectType.DOCUMENT,\n                  metadata: doc.metadata,\n                },\n              },\n            })\n          : doc,\n      );\n    }\n\n    let nodes: BaseNode[] = this.chunks;\n    for (const extractor of transformations) {\n      nodes = await extractor.processNodes(nodes);\n    }\n\n    this.chunks = this.chunks.map((doc, i) => {\n      return new Chunk({\n        text: doc.text,\n        metadata: {\n          ...doc.metadata,\n          ...(nodes?.[i]?.metadata || {}),\n        },\n      });\n    });\n\n    return this;\n  }\n\n  static fromText(text: string, metadata?: Record<string, any>): MDocument {\n    return new MDocument({\n      docs: [\n        {\n          text,\n          metadata,\n        },\n      ],\n      type: 'text',\n    });\n  }\n\n  static fromHTML(html: string, metadata?: Record<string, any>): MDocument {\n    return new MDocument({\n      docs: [\n        {\n          text: html,\n          metadata,\n        },\n      ],\n      type: 'html',\n    });\n  }\n\n  static fromMarkdown(markdown: string, metadata?: Record<string, any>): MDocument {\n    return new MDocument({\n      docs: [\n        {\n          text: markdown,\n          metadata,\n        },\n      ],\n      type: 'markdown',\n    });\n  }\n\n  static fromJSON(jsonString: string, metadata?: Record<string, any>): MDocument {\n    return new MDocument({\n      docs: [\n        {\n          text: jsonString,\n          metadata,\n        },\n      ],\n      type: 'json',\n    });\n  }\n\n  private defaultStrategy(): ChunkStrategy {\n    switch (this.type) {\n      case 'html':\n        return 'html';\n      case 'markdown':\n        return 'markdown';\n      case 'json':\n        return 'json';\n      case 'latex':\n        return 'latex';\n      default:\n        return 'recursive';\n    }\n  }\n\n  private _strategyMap?: { [S in ChunkStrategy]: (options?: StrategyOptions[S]) => Promise<void> };\n\n  private get strategyMap() {\n    if (!this._strategyMap) {\n      this._strategyMap = {\n        recursive: options => this.chunkRecursive(options),\n        character: options => this.chunkCharacter(options),\n        token: options => this.chunkToken(options),\n        markdown: options => this.chunkMarkdown(options),\n        html: options => this.chunkHTML(options),\n        json: options => this.chunkJSON(options),\n        latex: options => this.chunkLatex(options),\n        sentence: options => this.chunkSentence(options),\n        'semantic-markdown': options => this.chunkSemanticMarkdown(options),\n      };\n    }\n    return this._strategyMap;\n  }\n\n  private async chunkBy<K extends ChunkStrategy>(strategy: K, options?: StrategyOptions[K]): Promise<void> {\n    const chunkingFunc = this.strategyMap[strategy];\n    if (chunkingFunc) {\n      await chunkingFunc(options);\n    } else {\n      throw new Error(`Unknown strategy: ${strategy}`);\n    }\n  }\n\n  async chunkRecursive(options?: RecursiveChunkOptions): Promise<void> {\n    if (options?.language) {\n      const rt = RecursiveCharacterTransformer.fromLanguage(options.language, options);\n      const textSplit = rt.transformDocuments(this.chunks);\n      this.chunks = textSplit;\n      return;\n    }\n\n    const rt = new RecursiveCharacterTransformer(options);\n    const textSplit = rt.transformDocuments(this.chunks);\n    this.chunks = textSplit;\n  }\n\n  async chunkCharacter(options?: CharacterChunkOptions): Promise<void> {\n    const rt = new CharacterTransformer({\n      ...options,\n      separator: options?.separator,\n      isSeparatorRegex: options?.isSeparatorRegex,\n    });\n    const textSplit = rt.transformDocuments(this.chunks);\n    this.chunks = textSplit;\n  }\n\n  async chunkHTML(options?: HTMLChunkOptions): Promise<void> {\n    if (options?.headers?.length) {\n      const rt = new HTMLHeaderTransformer(options as HTMLChunkOptions & { headers: [string, string][] });\n\n      const textSplit = rt.transformDocuments(this.chunks);\n      this.chunks = textSplit;\n      return;\n    }\n\n    if (options?.sections?.length) {\n      const rt = new HTMLSectionTransformer(options as HTMLChunkOptions & { sections: [string, string][] });\n\n      const textSplit = rt.transformDocuments(this.chunks);\n      this.chunks = textSplit;\n      return;\n    }\n\n    throw new Error('HTML chunking requires either headers or sections to be specified');\n  }\n\n  async chunkJSON(options?: JsonChunkOptions): Promise<void> {\n    if (!options?.maxSize) {\n      throw new Error('JSON chunking requires maxSize to be specified');\n    }\n\n    const rt = new RecursiveJsonTransformer({\n      maxSize: options?.maxSize,\n      minSize: options?.minSize,\n    });\n\n    const textSplit = rt.transformDocuments({\n      documents: this.chunks,\n      ensureAscii: options?.ensureAscii,\n      convertLists: options?.convertLists,\n    });\n\n    this.chunks = textSplit;\n  }\n\n  async chunkLatex(options?: LatexChunkOptions): Promise<void> {\n    const rt = new LatexTransformer(options);\n    const textSplit = rt.transformDocuments(this.chunks);\n    this.chunks = textSplit;\n  }\n\n  async chunkToken(options?: TokenChunkOptions): Promise<void> {\n    const rt = TokenTransformer.fromTikToken({\n      options,\n      encodingName: options?.encodingName,\n      modelName: options?.modelName,\n    });\n    const textSplit = rt.transformDocuments(this.chunks);\n    this.chunks = textSplit;\n  }\n\n  async chunkMarkdown(options?: MarkdownChunkOptions): Promise<void> {\n    if (options?.headers) {\n      const rt = new MarkdownHeaderTransformer(options.headers, options?.returnEachLine, options?.stripHeaders);\n      const textSplit = rt.transformDocuments(this.chunks);\n      this.chunks = textSplit;\n      return;\n    }\n\n    const rt = new MarkdownTransformer(options);\n    const textSplit = rt.transformDocuments(this.chunks);\n    this.chunks = textSplit;\n  }\n\n  async chunkSentence(options?: SentenceChunkOptions): Promise<void> {\n    if (!options?.maxSize) {\n      throw new Error('Sentence chunking requires maxSize to be specified');\n    }\n\n    const rt = new SentenceTransformer({\n      minSize: options?.minSize,\n      maxSize: options?.maxSize,\n      targetSize: options?.targetSize,\n      overlap: options?.overlap,\n      sentenceEnders: options?.sentenceEnders,\n      fallbackToWords: options?.fallbackToWords,\n      fallbackToCharacters: options?.fallbackToCharacters,\n      keepSeparator: options?.keepSeparator,\n      lengthFunction: options?.lengthFunction,\n      addStartIndex: options?.addStartIndex,\n      stripWhitespace: options?.stripWhitespace,\n    });\n\n    const textSplit = rt.transformDocuments(this.chunks);\n    this.chunks = textSplit;\n  }\n\n  async chunkSemanticMarkdown(options?: SemanticMarkdownChunkOptions): Promise<void> {\n    const rt = SemanticMarkdownTransformer.fromTikToken({\n      options,\n      encodingName: options?.encodingName,\n      modelName: options?.modelName,\n    });\n    const textSplit = rt.transformDocuments(this.chunks);\n    this.chunks = textSplit;\n  }\n\n  async chunk(params?: ChunkParams): Promise<Chunk[]> {\n    const { strategy: passedStrategy, extract, ...chunkOptions } = params || {};\n    // Determine the default strategy based on type if not specified\n    const strategy = passedStrategy || this.defaultStrategy();\n\n    validateChunkParams(strategy, chunkOptions);\n\n    // Apply the appropriate chunking strategy\n    await this.chunkBy(strategy, chunkOptions);\n\n    if (extract) {\n      await this.extractMetadata(extract);\n    }\n\n    return this.chunks;\n  }\n\n  getDocs(): Chunk[] {\n    return this.chunks;\n  }\n\n  getText(): string[] {\n    return this.chunks.map(doc => doc.text);\n  }\n\n  getMetadata(): Record<string, any>[] {\n    return this.chunks.map(doc => doc.metadata);\n  }\n}\n","import type { RelevanceScoreProvider } from '@mastra/core/relevance';\n\ninterface CohereRerankingResponse {\n  results: Array<{\n    index: number;\n    relevance_score: number;\n  }>;\n  id: string;\n  meta: {\n    api_version: {\n      version: string;\n      is_experimental: boolean;\n    };\n    billed_units: {\n      search_units: number;\n    };\n  };\n}\n\nexport class CohereRelevanceScorer implements RelevanceScoreProvider {\n  private model: string;\n  private apiKey?: string;\n  constructor(model: string, apiKey?: string) {\n    this.apiKey = apiKey;\n    this.model = model;\n  }\n\n  async getRelevanceScore(query: string, text: string): Promise<number> {\n    const response = await fetch(`https://api.cohere.com/v2/rerank`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${this.apiKey}`,\n      },\n      body: JSON.stringify({\n        query,\n        documents: [text],\n        model: this.model,\n        top_n: 1,\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Cohere API error: ${response.status} ${await response.text()}`);\n    }\n\n    const data = (await response.json()) as CohereRerankingResponse;\n    const relevanceScore = data.results[0]?.relevance_score;\n\n    if (!relevanceScore) {\n      throw new Error('No relevance score found on Cohere response');\n    }\n\n    return relevanceScore;\n  }\n}\n","import { Agent } from '@mastra/core/agent';\nimport type { MastraLanguageModel } from '@mastra/core/agent';\nimport { createSimilarityPrompt } from '@mastra/core/relevance';\nimport type { RelevanceScoreProvider } from '@mastra/core/relevance';\n\n// Mastra Agent implementation\nexport class MastraAgentRelevanceScorer implements RelevanceScoreProvider {\n  private agent: Agent;\n\n  constructor(name: string, model: MastraLanguageModel) {\n    this.agent = new Agent({\n      name: `Relevance Scorer ${name}`,\n      instructions: `You are a specialized agent for evaluating the relevance of text to queries.\nYour task is to rate how well a text passage answers a given query.\nOutput only a number between 0 and 1, where:\n1.0 = Perfectly relevant, directly answers the query\n0.0 = Completely irrelevant\nConsider:\n- Direct relevance to the question\n- Completeness of information\n- Quality and specificity\nAlways return just the number, no explanation.`,\n      model,\n    });\n  }\n\n  async getRelevanceScore(query: string, text: string): Promise<number> {\n    const prompt = createSimilarityPrompt(query, text);\n\n    const model = await this.agent.getModel();\n    let response;\n\n    if (model.specificationVersion === 'v2') {\n      response = await this.agent.generate(prompt);\n    } else {\n      response = await this.agent.generateLegacy(prompt);\n    }\n\n    return parseFloat(response.text);\n  }\n}\n","import type { RelevanceScoreProvider } from '@mastra/core/relevance';\nimport ZeroEntropy from 'zeroentropy';\n\n// ZeroEntropy implementation\nexport class ZeroEntropyRelevanceScorer implements RelevanceScoreProvider {\n  private client: ZeroEntropy;\n  private model: string;\n\n  constructor(model?: string, apiKey?: string) {\n    this.client = new ZeroEntropy({\n      apiKey: apiKey || process.env.ZEROENTROPY_API_KEY || '',\n    });\n    this.model = model || 'zerank-1';\n  }\n\n  async getRelevanceScore(query: string, text: string): Promise<number> {\n    const response = await this.client.models.rerank({\n      query,\n      documents: [text],\n      model: this.model,\n      top_n: 1,\n    });\n\n    return response.results[0]?.relevance_score ?? 0;\n  }\n}\n","import type { MastraLanguageModel } from '@mastra/core/agent';\nimport type { RelevanceScoreProvider } from '@mastra/core/relevance';\nimport type { QueryResult } from '@mastra/core/vector';\nimport { Big } from 'big.js';\nimport { MastraAgentRelevanceScorer, CohereRelevanceScorer } from './relevance';\n\n// Default weights for different scoring components (must add up to 1)\nconst DEFAULT_WEIGHTS = {\n  semantic: 0.4,\n  vector: 0.4,\n  position: 0.2,\n} as const;\n\ntype WeightConfig = {\n  semantic?: number;\n  vector?: number;\n  position?: number;\n};\n\ninterface ScoringDetails {\n  semantic: number;\n  vector: number;\n  position: number;\n  queryAnalysis?: {\n    magnitude: number;\n    dominantFeatures: number[];\n  };\n}\n\nexport interface RerankResult {\n  result: QueryResult;\n  score: number;\n  details: ScoringDetails;\n}\n\n// For use in the vector store tool\nexport interface RerankerOptions {\n  weights?: WeightConfig;\n  topK?: number;\n}\n\n// For use in the rerank function\nexport interface RerankerFunctionOptions {\n  weights?: WeightConfig;\n  queryEmbedding?: number[];\n  topK?: number;\n}\n\nexport interface RerankConfig {\n  options?: RerankerOptions;\n  model: MastraLanguageModel | RelevanceScoreProvider;\n}\n\n// Calculate position score based on position in original list\nfunction calculatePositionScore(position: number, totalChunks: number): number {\n  return 1 - position / totalChunks;\n}\n\n// Analyze query embedding features if needed\nfunction analyzeQueryEmbedding(embedding: number[]): {\n  magnitude: number;\n  dominantFeatures: number[];\n} {\n  // Calculate embedding magnitude\n  const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));\n\n  // Find dominant features (highest absolute values)\n  const dominantFeatures = embedding\n    .map((value, index) => ({ value: Math.abs(value), index }))\n    .sort((a, b) => b.value - a.value)\n    .slice(0, 5)\n    .map(item => item.index);\n\n  return { magnitude, dominantFeatures };\n}\n\n// Adjust scores based on query characteristics\nfunction adjustScores(score: number, queryAnalysis: { magnitude: number; dominantFeatures: number[] }): number {\n  const magnitudeAdjustment = queryAnalysis.magnitude > 10 ? 1.1 : 1;\n\n  const featureStrengthAdjustment = queryAnalysis.magnitude > 5 ? 1.05 : 1;\n\n  return score * magnitudeAdjustment * featureStrengthAdjustment;\n}\n\nasync function executeRerank({\n  results,\n  query,\n  scorer,\n  options,\n}: {\n  results: QueryResult[];\n  query: string;\n  scorer: RelevanceScoreProvider;\n  options: RerankerFunctionOptions;\n}) {\n  const { queryEmbedding, topK = 3 } = options;\n  const weights = {\n    ...DEFAULT_WEIGHTS,\n    ...options.weights,\n  };\n\n  //weights must add up to 1\n  const sum = Object.values(weights).reduce((acc: Big, w: number) => acc.plus(w.toString()), new Big(0));\n  if (!sum.eq(1)) {\n    throw new Error(`Weights must add up to 1. Got ${sum} from ${weights}`);\n  }\n\n  const resultLength = results.length;\n\n  const queryAnalysis = queryEmbedding ? analyzeQueryEmbedding(queryEmbedding) : null;\n\n  // Get scores for each result\n  const scoredResults = await Promise.all(\n    results.map(async (result, index) => {\n      // Get semantic score from chosen provider\n      let semanticScore = 0;\n      if (result?.metadata?.text) {\n        semanticScore = await scorer.getRelevanceScore(query, result?.metadata?.text);\n      }\n\n      // Get existing vector score from result\n      const vectorScore = result.score;\n\n      // Get score of vector based on position in original list\n      const positionScore = calculatePositionScore(index, resultLength);\n\n      // Combine scores using weights for each component\n      let finalScore =\n        weights.semantic * semanticScore + weights.vector * vectorScore + weights.position * positionScore;\n\n      if (queryAnalysis) {\n        finalScore = adjustScores(finalScore, queryAnalysis);\n      }\n\n      return {\n        result,\n        score: finalScore,\n        details: {\n          semantic: semanticScore,\n          vector: vectorScore,\n          position: positionScore,\n          ...(queryAnalysis && {\n            queryAnalysis: {\n              magnitude: queryAnalysis.magnitude,\n              dominantFeatures: queryAnalysis.dominantFeatures,\n            },\n          }),\n        },\n      };\n    }),\n  );\n\n  // Sort by score and take top K\n  return scoredResults.sort((a, b) => b.score - a.score).slice(0, topK);\n}\n\nexport async function rerankWithScorer({\n  results,\n  query,\n  scorer,\n  options,\n}: {\n  results: QueryResult[];\n  query: string;\n  scorer: RelevanceScoreProvider;\n  options: RerankerFunctionOptions;\n}): Promise<RerankResult[]> {\n  return executeRerank({\n    results,\n    query,\n    scorer,\n    options,\n  });\n}\n\n// Takes in a list of results from a vector store and reranks them based on semantic, vector, and position scores\nexport async function rerank(\n  results: QueryResult[],\n  query: string,\n  model: MastraLanguageModel,\n  options: RerankerFunctionOptions,\n): Promise<RerankResult[]> {\n  let semanticProvider: RelevanceScoreProvider;\n\n  if (model.modelId === 'rerank-v3.5') {\n    semanticProvider = new CohereRelevanceScorer(model.modelId);\n  } else {\n    semanticProvider = new MastraAgentRelevanceScorer(model.provider, model);\n  }\n\n  return executeRerank({\n    results,\n    query,\n    scorer: semanticProvider,\n    options,\n  });\n}\n","/**\n * TODO: GraphRAG Enhancements\n *  - Add support for more edge types (sequential, hierarchical, citation, etc)\n *  - Allow for custom edge types\n *  - Utilize metadata for richer connections\n *  - Improve graph traversal and querying using types\n */\ntype SupportedEdgeType = 'semantic';\ntype GraphMetadata = Record<string, any>;\n\n// Types for graph nodes and edges\nexport interface GraphNode {\n  id: string;\n  content: string;\n  embedding?: number[];\n  metadata?: GraphMetadata;\n}\n\nexport interface RankedNode extends GraphNode {\n  score: number;\n}\n\nexport interface GraphEdge {\n  source: string;\n  target: string;\n  weight: number;\n  type: SupportedEdgeType;\n}\n\nexport interface GraphChunk {\n  text: string;\n  metadata: Record<string, any>;\n}\n\nexport interface GraphEmbedding {\n  vector: number[];\n}\n\nexport class GraphRAG {\n  private nodes: Map<string, GraphNode>;\n  private edges: GraphEdge[];\n  private dimension: number;\n  private threshold: number;\n\n  constructor(dimension: number = 1536, threshold: number = 0.7) {\n    this.nodes = new Map();\n    this.edges = [];\n    this.dimension = dimension;\n    this.threshold = threshold;\n  }\n\n  // Add a node to the graph\n  addNode(node: GraphNode): void {\n    if (!node.embedding) {\n      throw new Error('Node must have an embedding');\n    }\n    if (node.embedding.length !== this.dimension) {\n      throw new Error(`Embedding dimension must be ${this.dimension}`);\n    }\n    this.nodes.set(node.id, node);\n  }\n\n  // Add an edge between two nodes\n  addEdge(edge: GraphEdge): void {\n    if (!this.nodes.has(edge.source) || !this.nodes.has(edge.target)) {\n      throw new Error('Both source and target nodes must exist');\n    }\n    this.edges.push(edge);\n    // Add reverse edge\n    this.edges.push({\n      source: edge.target,\n      target: edge.source,\n      weight: edge.weight,\n      type: edge.type,\n    });\n  }\n\n  // Helper method to get all nodes\n  getNodes(): GraphNode[] {\n    return Array.from(this.nodes.values());\n  }\n\n  // Helper method to get all edges\n  getEdges(): GraphEdge[] {\n    return this.edges;\n  }\n\n  getEdgesByType(type: string): GraphEdge[] {\n    return this.edges.filter(edge => edge.type === type);\n  }\n\n  clear(): void {\n    this.nodes.clear();\n    this.edges = [];\n  }\n\n  updateNodeContent(id: string, newContent: string): void {\n    const node = this.nodes.get(id);\n    if (!node) {\n      throw new Error(`Node ${id} not found`);\n    }\n    node.content = newContent;\n  }\n\n  // Get neighbors of a node\n  private getNeighbors(nodeId: string, edgeType?: string): { id: string; weight: number }[] {\n    return this.edges\n      .filter(edge => edge.source === nodeId && (!edgeType || edge.type === edgeType))\n      .map(edge => ({\n        id: edge.target,\n        weight: edge.weight,\n      }))\n      .filter(node => node !== undefined);\n  }\n\n  // Calculate cosine similarity between two vectors\n  private cosineSimilarity(vec1: number[], vec2: number[]): number {\n    if (!vec1 || !vec2) {\n      throw new Error('Vectors must not be null or undefined');\n    }\n    const vectorLength = vec1.length;\n\n    if (vectorLength !== vec2.length) {\n      throw new Error(`Vector dimensions must match: vec1(${vec1.length}) !== vec2(${vec2.length})`);\n    }\n\n    let dotProduct = 0;\n    let normVec1 = 0;\n    let normVec2 = 0;\n\n    for (let i = 0; i < vectorLength; i++) {\n      const a = vec1[i]!; // Non-null assertion operator\n      const b = vec2[i]!;\n\n      dotProduct += a * b;\n      normVec1 += a * a;\n      normVec2 += b * b;\n    }\n    const magnitudeProduct = Math.sqrt(normVec1 * normVec2);\n\n    if (magnitudeProduct === 0) {\n      return 0;\n    }\n\n    const similarity = dotProduct / magnitudeProduct;\n    return Math.max(-1, Math.min(1, similarity));\n  }\n\n  createGraph(chunks: GraphChunk[], embeddings: GraphEmbedding[]) {\n    if (!chunks?.length || !embeddings?.length) {\n      throw new Error('Chunks and embeddings arrays must not be empty');\n    }\n    if (chunks.length !== embeddings.length) {\n      throw new Error('Chunks and embeddings must have the same length');\n    }\n    // Create nodes from chunks\n    chunks.forEach((chunk, index) => {\n      const node: GraphNode = {\n        id: index.toString(),\n        content: chunk.text,\n        embedding: embeddings[index]?.vector,\n        metadata: { ...chunk.metadata },\n      };\n      this.addNode(node);\n      this.nodes.set(node.id, node);\n    });\n\n    // Create edges based on cosine similarity\n    for (let i = 0; i < chunks.length; i++) {\n      const firstEmbedding = embeddings[i]?.vector as number[];\n      for (let j = i + 1; j < chunks.length; j++) {\n        const secondEmbedding = embeddings[j]?.vector as number[];\n        const similarity = this.cosineSimilarity(firstEmbedding, secondEmbedding);\n\n        // Only create edges if similarity is above threshold\n        if (similarity > this.threshold) {\n          this.addEdge({\n            source: i.toString(),\n            target: j.toString(),\n            weight: similarity,\n            type: 'semantic',\n          });\n        }\n      }\n    }\n  }\n\n  private selectWeightedNeighbor(neighbors: Array<{ id: string; weight: number }>): string {\n    // Sum all weights to normalize probabilities\n    const totalWeight = neighbors.reduce((sum, n) => sum + n.weight, 0);\n\n    // Pick a random point in the total weight range\n    let remainingWeight = Math.random() * totalWeight;\n\n    // Subtract each weight from our random value until we go below 0\n    // Higher weights will make us go below 0 more often, making them more likely to be selected\n    for (const neighbor of neighbors) {\n      remainingWeight -= neighbor.weight;\n      if (remainingWeight <= 0) {\n        return neighbor.id;\n      }\n    }\n\n    return neighbors[neighbors.length - 1]?.id as string;\n  }\n\n  // Perform random walk with restart\n  private randomWalkWithRestart(\n    startNodeId: string,\n    steps: number,\n    restartProb: number,\n    allowedNodeIds?: Set<string>,\n  ): Map<string, number> {\n    const visits = new Map<string, number>();\n    let currentNodeId = startNodeId;\n\n    for (let step = 0; step < steps; step++) {\n      // Record visit\n      visits.set(currentNodeId, (visits.get(currentNodeId) || 0) + 1);\n\n      // Decide whether to restart\n      if (Math.random() < restartProb) {\n        currentNodeId = startNodeId;\n        continue;\n      }\n\n      // Get neighbors\n      let neighbors = this.getNeighbors(currentNodeId);\n      if (allowedNodeIds) {\n        neighbors = neighbors.filter(n => allowedNodeIds.has(n.id));\n      }\n      if (neighbors.length === 0) {\n        currentNodeId = startNodeId;\n        continue;\n      }\n\n      // Select random weighted neighbor and set as current node\n      currentNodeId = this.selectWeightedNeighbor(neighbors);\n    }\n\n    // Normalize visits\n    const totalVisits = Array.from(visits.values()).reduce((a, b) => a + b, 0);\n    const normalizedVisits = new Map<string, number>();\n    for (const [nodeId, count] of visits) {\n      normalizedVisits.set(nodeId, count / totalVisits);\n    }\n\n    return normalizedVisits;\n  }\n\n  /**\n   * Query the graph with a dense embedding and optional metadata filter.\n   *\n   * @param query - The embedding vector to query.\n   * @param topK - Number of top results to return.\n   * @param randomWalkSteps - Steps for random walk reranking.\n   * @param restartProb - Restart probability for random walk.\n   * @param filter - Optional strict metadata filter. All key-value pairs must match exactly.\n   */\n  // Retrieve relevant nodes using hybrid approach\n  query({\n    query,\n    topK = 10,\n    randomWalkSteps = 100,\n    restartProb = 0.15,\n    filter,\n  }: {\n    query: number[];\n    topK?: number;\n    randomWalkSteps?: number;\n    restartProb?: number;\n    filter?: Partial<GraphMetadata>;\n  }): RankedNode[] {\n    if (!query || query.length !== this.dimension) {\n      throw new Error(`Query embedding must have dimension ${this.dimension}`);\n    }\n    if (topK < 1) {\n      throw new Error('TopK must be greater than 0');\n    }\n    if (randomWalkSteps < 1) {\n      throw new Error('Random walk steps must be greater than 0');\n    }\n    if (restartProb <= 0 || restartProb >= 1) {\n      throw new Error('Restart probability must be between 0 and 1');\n    }\n\n    const filterEntries = Object.entries(filter ?? {});\n    const matchesFilter = (node: GraphNode) =>\n      filterEntries.length === 0 ? true : filterEntries.every(([key, value]) => node.metadata?.[key] === value);\n\n    const nodesToSearch = Array.from(this.nodes.values()).filter(matchesFilter);\n\n    // Retrieve nodes and calculate similarity\n    const similarities = nodesToSearch.map(node => ({\n      node,\n      similarity: this.cosineSimilarity(query, node.embedding!),\n    }));\n\n    // Sort by similarity\n    similarities.sort((a, b) => b.similarity - a.similarity);\n    const topNodes = similarities.slice(0, topK);\n\n    const useFilter = filterEntries.length > 0;\n    // Re-rank using random walk, but only over filtered nodes\n    const allowedNodeIds = useFilter ? new Set(nodesToSearch.map(n => n.id)) : undefined;\n\n    // Re-ranks nodes using random walk with restart\n    const rerankedNodes = new Map<string, { node: GraphNode; score: number }>();\n\n    // For each top node, perform random walk\n    for (const { node, similarity } of topNodes) {\n      const walkScores = this.randomWalkWithRestart(node.id, randomWalkSteps, restartProb, allowedNodeIds);\n\n      // Combine dense retrieval score with graph score\n      for (const [nodeId, walkScore] of walkScores) {\n        const node = this.nodes.get(nodeId)!;\n        const existingScore = rerankedNodes.get(nodeId)?.score || 0;\n        rerankedNodes.set(nodeId, {\n          node,\n          score: existingScore + similarity * walkScore,\n        });\n      }\n    }\n\n    // Sort by final score and return top K nodes\n    return Array.from(rerankedNodes.values())\n      .sort((a, b) => b.score - a.score)\n      .slice(0, topK)\n      .map(item => ({\n        id: item.node.id,\n        content: item.node.content,\n        metadata: item.node.metadata,\n        score: item.score,\n      }));\n  }\n}\n","import { createTool } from '@mastra/core/tools';\nimport { z } from 'zod';\n\nimport type { MDocument, ChunkParams } from '../document';\n\nconst DEFAULT_CHUNK_PARAMS = {\n  strategy: 'recursive' as const,\n  maxSize: 512,\n  overlap: 50,\n  separators: ['\\n'],\n} satisfies ChunkParams;\n\nexport const createDocumentChunkerTool = ({\n  doc,\n  params = DEFAULT_CHUNK_PARAMS,\n}: {\n  doc: MDocument;\n  params?: ChunkParams;\n}): ReturnType<typeof createTool> => {\n  return createTool({\n    id: `Document Chunker ${params.strategy} ${params.maxSize}`,\n    inputSchema: z.object({}),\n    description: `Chunks document using ${params.strategy} strategy with maxSize ${params.maxSize} and ${\n      params.overlap || 0\n    } overlap`,\n    execute: async () => {\n      const chunks = await doc.chunk(params);\n\n      return {\n        chunks,\n      };\n    },\n  });\n};\n","import type { MastraVector, MastraEmbeddingModel, QueryResult, QueryVectorParams } from '@mastra/core/vector';\nimport { embedV1, embedV2 } from '@mastra/core/vector';\nimport type { VectorFilter } from '@mastra/core/vector/filter';\nimport type { DatabaseConfig, ProviderOptions } from '../tools/types';\n\ntype VectorQuerySearchParams = {\n  indexName: string;\n  vectorStore: MastraVector;\n  queryText: string;\n  model: MastraEmbeddingModel<string>;\n  queryFilter?: VectorFilter;\n  topK: number;\n  includeVectors?: boolean;\n  maxRetries?: number;\n  /** Database-specific configuration options */\n  databaseConfig?: DatabaseConfig;\n} & ProviderOptions;\n\ninterface VectorQuerySearchResult {\n  results: QueryResult[];\n  queryEmbedding: number[];\n}\n\nenum DatabaseType {\n  Pinecone = 'pinecone',\n  PgVector = 'pgvector',\n  Chroma = 'chroma',\n}\n\nconst DATABASE_TYPE_MAP = Object.keys(DatabaseType);\n\n// Helper function to handle vector query search\nexport const vectorQuerySearch = async ({\n  indexName,\n  vectorStore,\n  queryText,\n  model,\n  queryFilter,\n  topK,\n  includeVectors = false,\n  maxRetries = 2,\n  databaseConfig = {},\n  providerOptions,\n}: VectorQuerySearchParams): Promise<VectorQuerySearchResult> => {\n  let embeddingResult;\n\n  if (model.specificationVersion === 'v2') {\n    embeddingResult = await embedV2({\n      model: model,\n      value: queryText,\n      maxRetries,\n      ...(providerOptions && { providerOptions }),\n    });\n  } else {\n    embeddingResult = await embedV1({\n      value: queryText,\n      model: model,\n      maxRetries,\n    });\n  }\n\n  const embedding = embeddingResult.embedding;\n\n  // Build query parameters with database-specific configurations\n  const queryParams: QueryVectorParams = {\n    indexName,\n    queryVector: embedding,\n    topK,\n    filter: queryFilter,\n    includeVector: includeVectors,\n  };\n\n  // Get relevant chunks from the vector database\n  const results = await vectorStore.query({ ...queryParams, ...databaseSpecificParams(databaseConfig) });\n\n  return { results, queryEmbedding: embedding };\n};\n\nconst databaseSpecificParams = (databaseConfig: DatabaseConfig) => {\n  const databaseSpecificParams: DatabaseConfig = {};\n\n  // Apply database-specific configurations\n  if (databaseConfig) {\n    // Pinecone-specific configurations\n    if (databaseConfig.pinecone) {\n      if (databaseConfig.pinecone.namespace) {\n        databaseSpecificParams.namespace = databaseConfig.pinecone.namespace;\n      }\n      if (databaseConfig.pinecone.sparseVector) {\n        databaseSpecificParams.sparseVector = databaseConfig.pinecone.sparseVector;\n      }\n    }\n\n    // pgVector-specific configurations\n    if (databaseConfig.pgvector) {\n      if (databaseConfig.pgvector.minScore !== undefined) {\n        databaseSpecificParams.minScore = databaseConfig.pgvector.minScore;\n      }\n      if (databaseConfig.pgvector.ef !== undefined) {\n        databaseSpecificParams.ef = databaseConfig.pgvector.ef;\n      }\n      if (databaseConfig.pgvector.probes !== undefined) {\n        databaseSpecificParams.probes = databaseConfig.pgvector.probes;\n      }\n    }\n\n    // Chroma-specific configurations\n    if (databaseConfig.chroma) {\n      if (databaseConfig.chroma.where) {\n        databaseSpecificParams.where = databaseConfig.chroma.where;\n      }\n      if (databaseConfig.chroma.whereDocument) {\n        databaseSpecificParams.whereDocument = databaseConfig.chroma.whereDocument;\n      }\n    }\n\n    // Handle any additional database configs\n    Object.keys(databaseConfig).forEach(dbName => {\n      if (!DATABASE_TYPE_MAP.includes(dbName)) {\n        // For unknown database types, merge the config directly\n        const config = databaseConfig[dbName];\n        if (config && typeof config === 'object') {\n          Object.assign(databaseSpecificParams, config);\n        }\n      }\n    });\n  }\n\n  return databaseSpecificParams;\n};\n","export const defaultVectorQueryDescription = () =>\n  `Access the knowledge base to find information needed to answer user questions.`;\n\nexport const defaultGraphRagDescription = () =>\n  `Access and analyze relationships between information in the knowledge base to answer complex questions about connections and patterns.`;\n\nexport const queryTextDescription = `The text query to search for in the vector database.\n- ALWAYS provide a non-empty query string\n- Must contain the user's question or search terms\n- Example: \"market data\" or \"financial reports\"\n- If the user's query is about a specific topic, use that topic as the queryText\n- Cannot be an empty string\n- Do not include quotes, just the text itself\n- Required for all searches`;\n\nexport const topKDescription = `Controls how many matching documents to return.\n- ALWAYS provide a value\n- If no value is provided, use the default (10)\n- Must be a valid and positive number\n- Cannot be NaN\n- Uses provided value if specified\n- Default: 10 results (use this if unsure)\n- Higher values (like 20) provide more context\n- Lower values (like 3) focus on best matches\n- Based on query requirements`;\n\nexport const filterDescription = `JSON-formatted criteria to refine search results.\n- ALWAYS provide a filter value\n- If no filter is provided, use the default (\"{}\")\n- MUST be a valid, complete JSON object with proper quotes and brackets\n- Uses provided filter if specified\n- Default: \"{}\" (no filtering)\n- Example for no filtering: \"filter\": \"{}\"\n- Example: '{\"category\": \"health\"}'\n- Based on query intent\n- Do NOT use single quotes or unquoted properties\n- IMPORTANT: Always ensure JSON is properly closed with matching brackets\n- Multiple filters can be combined`;\n","import type { Tool } from '@mastra/core/tools';\nimport { z } from 'zod';\nimport { queryTextDescription, topKDescription, filterDescription } from './default-settings';\n\nexport const baseSchema = {\n  queryText: z.string().describe(queryTextDescription),\n  topK: z.coerce.number().describe(topKDescription),\n};\n\n// Output schema includes `sources`, which exposes the full set of retrieved chunks (QueryResult objects)\n// Each source contains all information needed to reference\n// the original document, chunk, and similarity score.\nexport const outputSchema = z.object({\n  // Array of metadata or content for compatibility with prior usage\n  relevantContext: z.any(),\n  // Array of full retrieval result objects\n  sources: z.array(\n    z.object({\n      id: z.string(), // Unique chunk/document identifier\n      metadata: z.any(), // All metadata fields (document ID, etc.)\n      vector: z.array(z.number()), // Embedding vector (if available)\n      score: z.number(), // Similarity score for this retrieval\n      document: z.string(), // Full chunk/document text (if available)\n    }),\n  ),\n});\n\nexport const filterSchema = z.object({\n  ...baseSchema,\n  filter: z.coerce.string().describe(filterDescription),\n});\n\nexport type RagTool<\n  TInput extends z.ZodType<any, z.ZodTypeDef, any> | undefined,\n  TOutput extends z.ZodType<any, z.ZodTypeDef, any> | undefined,\n> = Tool<TInput, TOutput> & {\n  execute: NonNullable<Tool<TInput, TOutput>['execute']>;\n};\n","import type { QueryResult } from '@mastra/core/vector';\nimport type { RankedNode } from '../graph-rag';\nimport type { RerankResult } from '../rerank';\n\ntype SourceInput = QueryResult | RankedNode | RerankResult;\n\n/**\n * Convert an array of source inputs (QueryResult, RankedNode, or RerankResult) to an array of sources.\n * @param results Array of source inputs to convert.\n * @returns Array of sources.\n */\nexport const convertToSources = (results: SourceInput[]) => {\n  return results.map(result => {\n    // RankedNode\n    if ('content' in result) {\n      return {\n        id: result.id,\n        vector: result.embedding || [],\n        score: result.score,\n        metadata: result.metadata,\n        document: result.content || '',\n      };\n    }\n    // RerankResult\n    if ('result' in result) {\n      return {\n        id: result.result.id,\n        vector: result.result.vector || [],\n        score: result.score,\n        metadata: result.result.metadata,\n        document: result.result.document || '',\n      };\n    }\n    // QueryResult\n    return {\n      id: result.id,\n      vector: result.vector || [],\n      score: result.score,\n      metadata: result.metadata,\n      document: result.document || '',\n    };\n  });\n};\n","import type { MastraVector, MastraEmbeddingModel } from '@mastra/core/vector';\n\nimport type { RerankConfig } from '../rerank';\n\nexport interface PineconeConfig {\n  namespace?: string;\n  sparseVector?: {\n    indices: number[];\n    values: number[];\n  };\n}\n\nexport interface PgVectorConfig {\n  minScore?: number;\n  ef?: number; // HNSW search parameter\n  probes?: number; // IVFFlat probe parameter\n}\n\n// Chroma types\ntype LiteralValue = string | number | boolean;\ntype ListLiteralValue = LiteralValue[];\ntype LiteralNumber = number;\ntype LogicalOperator = '$and' | '$or';\ntype InclusionOperator = '$in' | '$nin';\ntype WhereOperator = '$gt' | '$gte' | '$lt' | '$lte' | '$ne' | '$eq';\ntype OperatorExpression = {\n  [key in WhereOperator | InclusionOperator | LogicalOperator]?: LiteralValue | ListLiteralValue;\n};\ntype BaseWhere = {\n  [key: string]: LiteralValue | OperatorExpression;\n};\ntype LogicalWhere = {\n  [key in LogicalOperator]?: Where[];\n};\ntype Where = BaseWhere | LogicalWhere;\ntype WhereDocumentOperator = '$contains' | '$not_contains' | LogicalOperator;\ntype WhereDocument = {\n  [key in WhereDocumentOperator]?: LiteralValue | LiteralNumber | WhereDocument[];\n};\n\nexport interface ChromaConfig {\n  // Add Chroma-specific configs here if needed\n  where?: Where;\n  whereDocument?: WhereDocument;\n}\n\n// Union type for all database-specific configs\nexport type DatabaseConfig = {\n  pinecone?: PineconeConfig;\n  pgvector?: PgVectorConfig;\n  chroma?: ChromaConfig;\n  // Add other database configs as needed\n  [key: string]: any; // Allow for future database extensions\n};\n\nexport type VectorQueryToolOptions = {\n  id?: string;\n  description?: string;\n  indexName: string;\n  model: MastraEmbeddingModel<string>;\n  enableFilter?: boolean;\n  includeVectors?: boolean;\n  includeSources?: boolean;\n  reranker?: RerankConfig;\n  /** Database-specific configuration options */\n  databaseConfig?: DatabaseConfig;\n} & ProviderOptions &\n  (\n    | {\n        vectorStoreName: string;\n      }\n    | {\n        vectorStoreName?: string;\n        vectorStore: MastraVector;\n      }\n  );\n\nexport type GraphRagToolOptions = {\n  id?: string;\n  description?: string;\n  indexName: string;\n  vectorStoreName: string;\n  model: MastraEmbeddingModel<string>;\n  enableFilter?: boolean;\n  includeSources?: boolean;\n  graphOptions?: {\n    dimension?: number;\n    randomWalkSteps?: number;\n    restartProb?: number;\n    threshold?: number;\n  };\n} & ProviderOptions;\n\nexport type ProviderOptions = {\n  /**\n   * Provider-specific options for the embedding model (e.g., outputDimensionality).\n   *\n   *   **IMPORTANT**: `providerOptions` only work with AI SDK v2 models.\n   *\n   * **For v1 models**: Configure options when creating the model:\n   *  const model = openai.embedding('text-embedding-3-small', { dimensions: 512 });\n   *\n   * **For v2 models**: Use providerOptions:\n   *  providerOptions: { openai: { dimensions: 512 } }\n   */\n  providerOptions?: Record<string, Record<string, any>>;\n};\n\n/**\n * Default options for GraphRAG\n * @default\n * ```json\n * {\n *   \"dimension\": 1536,\n *   \"randomWalkSteps\": 100,\n *   \"restartProb\": 0.15,\n *   \"threshold\": 0.7\n * }\n * ```\n */\nexport const defaultGraphOptions = {\n  dimension: 1536,\n  randomWalkSteps: 100,\n  restartProb: 0.15,\n  threshold: 0.7,\n};\n","import { createTool } from '@mastra/core/tools';\nimport { z } from 'zod';\n\nimport { GraphRAG } from '../graph-rag';\nimport { vectorQuerySearch, defaultGraphRagDescription, filterSchema, outputSchema, baseSchema } from '../utils';\nimport type { RagTool } from '../utils';\nimport { convertToSources } from '../utils/convert-sources';\nimport type { GraphRagToolOptions } from './types';\nimport { defaultGraphOptions } from './types';\n\nexport const createGraphRAGTool = (options: GraphRagToolOptions) => {\n  const { model, id, description } = options;\n\n  const toolId = id || `GraphRAG ${options.vectorStoreName} ${options.indexName} Tool`;\n  const toolDescription = description || defaultGraphRagDescription();\n  const graphOptions = {\n    ...defaultGraphOptions,\n    ...(options.graphOptions || {}),\n  };\n  // Initialize GraphRAG\n  const graphRag = new GraphRAG(graphOptions.dimension, graphOptions.threshold);\n  let isInitialized = false;\n\n  const inputSchema = options.enableFilter ? filterSchema : z.object(baseSchema).passthrough();\n\n  return createTool({\n    id: toolId,\n    inputSchema,\n    outputSchema,\n    description: toolDescription,\n    execute: async ({ context, mastra, runtimeContext }) => {\n      const indexName: string = runtimeContext.get('indexName') ?? options.indexName;\n      const vectorStoreName: string = runtimeContext.get('vectorStoreName') ?? options.vectorStoreName;\n      if (!indexName) throw new Error(`indexName is required, got: ${indexName}`);\n      if (!vectorStoreName) throw new Error(`vectorStoreName is required, got: ${vectorStoreName}`);\n      const includeSources: boolean = runtimeContext.get('includeSources') ?? options.includeSources ?? true;\n      const randomWalkSteps: number | undefined = runtimeContext.get('randomWalkSteps') ?? graphOptions.randomWalkSteps;\n      const restartProb: number | undefined = runtimeContext.get('restartProb') ?? graphOptions.restartProb;\n      const topK: number = runtimeContext.get('topK') ?? context.topK ?? 10;\n      const filter: Record<string, any> = runtimeContext.get('filter') ?? context.filter;\n      const queryText = context.queryText;\n      const providerOptions: Record<string, Record<string, any>> | undefined =\n        runtimeContext.get('providerOptions') ?? options.providerOptions;\n\n      const enableFilter = !!runtimeContext.get('filter') || (options.enableFilter ?? false);\n\n      const logger = mastra?.getLogger();\n      if (!logger) {\n        console.warn(\n          '[GraphRAGTool] Logger not initialized: no debug or error logs will be recorded for this tool execution.',\n        );\n      }\n      if (logger) {\n        logger.debug('[GraphRAGTool] execute called with:', { queryText, topK, filter });\n      }\n      try {\n        const topKValue =\n          typeof topK === 'number' && !isNaN(topK)\n            ? topK\n            : typeof topK === 'string' && !isNaN(Number(topK))\n              ? Number(topK)\n              : 10;\n        const vectorStore = mastra?.getVector(vectorStoreName);\n\n        if (!vectorStore) {\n          if (logger) {\n            logger.error('Vector store not found', { vectorStoreName });\n          }\n          return { relevantContext: [], sources: [] };\n        }\n\n        let queryFilter = {};\n        if (enableFilter) {\n          queryFilter = (() => {\n            try {\n              return typeof filter === 'string' ? JSON.parse(filter) : filter;\n            } catch (error) {\n              if (logger) {\n                logger.error('Invalid filter', { filter, error });\n              }\n              throw new Error(`Invalid filter format: ${error instanceof Error ? error.message : String(error)}`);\n            }\n          })();\n        }\n        if (logger) {\n          logger.debug('Prepared vector query parameters:', { queryFilter, topK: topKValue });\n        }\n        const { results, queryEmbedding } = await vectorQuerySearch({\n          indexName,\n          vectorStore,\n          queryText,\n          model,\n          queryFilter: Object.keys(queryFilter || {}).length > 0 ? queryFilter : undefined,\n          topK: topKValue,\n          includeVectors: true,\n          providerOptions,\n        });\n        if (logger) {\n          logger.debug('vectorQuerySearch returned results', { count: results.length });\n        }\n\n        // Initialize graph if not done yet\n        if (!isInitialized) {\n          // Get all chunks and embeddings for graph construction\n          const chunks = results.map(result => ({\n            text: result?.metadata?.text,\n            metadata: result.metadata ?? {},\n          }));\n          const embeddings = results.map(result => ({\n            vector: result.vector || [],\n          }));\n\n          if (logger) {\n            logger.debug('Initializing graph', { chunkCount: chunks.length, embeddingCount: embeddings.length });\n          }\n          graphRag.createGraph(chunks, embeddings);\n          isInitialized = true;\n        } else if (logger) {\n          logger.debug('Graph already initialized, skipping graph construction');\n        }\n\n        // Get reranked results using GraphRAG\n        const rerankedResults = graphRag.query({\n          query: queryEmbedding,\n          topK: topKValue,\n          randomWalkSteps,\n          restartProb,\n        });\n        if (logger) {\n          logger.debug('GraphRAG query returned results', { count: rerankedResults.length });\n        }\n        // Extract and combine relevant chunks\n        const relevantChunks = rerankedResults.map(result => result.content);\n        if (logger) {\n          logger.debug('Returning relevant context chunks', { count: relevantChunks.length });\n        }\n        // `sources` exposes the full retrieval objects\n        const sources = includeSources ? convertToSources(rerankedResults) : [];\n        return {\n          relevantContext: relevantChunks,\n          sources,\n        };\n      } catch (err) {\n        if (logger) {\n          logger.error('Unexpected error in VectorQueryTool execute', {\n            error: err,\n            errorMessage: err instanceof Error ? err.message : String(err),\n            errorStack: err instanceof Error ? err.stack : undefined,\n          });\n        }\n        return { relevantContext: [], sources: [] };\n      }\n    },\n    // Use any for output schema as the structure of the output causes type inference issues\n  }) as RagTool<typeof inputSchema, any>;\n};\n","import { createTool } from '@mastra/core/tools';\nimport type { MastraVector, MastraEmbeddingModel } from '@mastra/core/vector';\nimport { z } from 'zod';\n\nimport { rerank, rerankWithScorer } from '../rerank';\nimport type { RerankConfig, RerankResult } from '../rerank';\nimport { vectorQuerySearch, defaultVectorQueryDescription, filterSchema, outputSchema, baseSchema } from '../utils';\nimport type { RagTool } from '../utils';\nimport { convertToSources } from '../utils/convert-sources';\nimport type { VectorQueryToolOptions } from './types';\n\nexport const createVectorQueryTool = (options: VectorQueryToolOptions) => {\n  const { id, description } = options;\n  const storeName = options['vectorStoreName'] ? options.vectorStoreName : 'DirectVectorStore';\n\n  const toolId = id || `VectorQuery ${storeName} ${options.indexName} Tool`;\n  const toolDescription = description || defaultVectorQueryDescription();\n  const inputSchema = options.enableFilter ? filterSchema : z.object(baseSchema).passthrough();\n\n  return createTool({\n    id: toolId,\n    description: toolDescription,\n    inputSchema,\n    outputSchema,\n    execute: async ({ context, mastra, runtimeContext }) => {\n      const indexName: string = runtimeContext.get('indexName') ?? options.indexName;\n      const vectorStoreName: string =\n        'vectorStore' in options ? storeName : (runtimeContext.get('vectorStoreName') ?? storeName);\n      const includeVectors: boolean = runtimeContext.get('includeVectors') ?? options.includeVectors ?? false;\n      const includeSources: boolean = runtimeContext.get('includeSources') ?? options.includeSources ?? true;\n      const reranker: RerankConfig = runtimeContext.get('reranker') ?? options.reranker;\n      const databaseConfig = runtimeContext.get('databaseConfig') ?? options.databaseConfig;\n      const model: MastraEmbeddingModel<string> = runtimeContext.get('model') ?? options.model;\n      const providerOptions: Record<string, Record<string, any>> | undefined =\n        runtimeContext.get('providerOptions') ?? options.providerOptions;\n\n      if (!indexName) throw new Error(`indexName is required, got: ${indexName}`);\n      if (!vectorStoreName) throw new Error(`vectorStoreName is required, got: ${vectorStoreName}`); // won't fire\n\n      const topK: number = runtimeContext.get('topK') ?? context.topK ?? 10;\n      const filter: Record<string, any> = runtimeContext.get('filter') ?? context.filter;\n      const queryText = context.queryText;\n      const enableFilter = !!runtimeContext.get('filter') || (options.enableFilter ?? false);\n\n      const logger = mastra?.getLogger();\n      if (!logger) {\n        console.warn(\n          '[VectorQueryTool] Logger not initialized: no debug or error logs will be recorded for this tool execution.',\n        );\n      }\n      if (logger) {\n        logger.debug('[VectorQueryTool] execute called with:', { queryText, topK, filter, databaseConfig });\n      }\n      try {\n        const topKValue =\n          typeof topK === 'number' && !isNaN(topK)\n            ? topK\n            : typeof topK === 'string' && !isNaN(Number(topK))\n              ? Number(topK)\n              : 10;\n\n        let vectorStore: MastraVector | undefined = undefined;\n        if ('vectorStore' in options) {\n          vectorStore = options.vectorStore;\n        } else if (mastra) {\n          vectorStore = mastra.getVector(vectorStoreName);\n        }\n        if (!vectorStore) {\n          if (logger) {\n            logger.error('Vector store not found', { vectorStoreName });\n          }\n          return { relevantContext: [], sources: [] };\n        }\n        // Get relevant chunks from the vector database\n        let queryFilter = {};\n        if (enableFilter && filter) {\n          queryFilter = (() => {\n            try {\n              return typeof filter === 'string' ? JSON.parse(filter) : filter;\n            } catch (error) {\n              if (logger) {\n                logger.error('Invalid filter', { filter, error });\n              }\n              throw new Error(`Invalid filter format: ${error instanceof Error ? error.message : String(error)}`);\n            }\n          })();\n        }\n        if (logger) {\n          logger.debug('Prepared vector query parameters', { queryText, topK: topKValue, queryFilter, databaseConfig });\n        }\n\n        const { results } = await vectorQuerySearch({\n          indexName,\n          vectorStore,\n          queryText,\n          model,\n          queryFilter: Object.keys(queryFilter || {}).length > 0 ? queryFilter : undefined,\n          topK: topKValue,\n          includeVectors,\n          databaseConfig,\n          providerOptions,\n        });\n        if (logger) {\n          logger.debug('vectorQuerySearch returned results', { count: results.length });\n        }\n\n        if (reranker) {\n          if (logger) {\n            logger.debug('Reranking results', { rerankerModel: reranker.model, rerankerOptions: reranker.options });\n          }\n\n          let rerankedResults: RerankResult[] = [];\n\n          if (typeof reranker?.model === 'object' && 'getRelevanceScore' in reranker?.model) {\n            rerankedResults = await rerankWithScorer({\n              results,\n              query: queryText,\n              scorer: reranker.model,\n              options: {\n                ...reranker.options,\n                topK: reranker.options?.topK || topKValue,\n              },\n            });\n          } else {\n            rerankedResults = await rerank(results, queryText, reranker.model, {\n              ...reranker.options,\n              topK: reranker.options?.topK || topKValue,\n            });\n          }\n\n          if (logger) {\n            logger.debug('Reranking complete', { rerankedCount: rerankedResults.length });\n          }\n\n          const relevantChunks = rerankedResults.map(({ result }) => result?.metadata);\n\n          if (logger) {\n            logger.debug('Returning reranked relevant context chunks', { count: relevantChunks.length });\n          }\n\n          const sources = includeSources ? convertToSources(rerankedResults) : [];\n\n          return { relevantContext: relevantChunks, sources };\n        }\n\n        const relevantChunks = results.map(result => result?.metadata);\n\n        if (logger) {\n          logger.debug('Returning relevant context chunks', { count: relevantChunks.length });\n        }\n        // `sources` exposes the full retrieval objects\n        const sources = includeSources ? convertToSources(results) : [];\n        return {\n          relevantContext: relevantChunks,\n          sources,\n        };\n      } catch (err) {\n        if (logger) {\n          logger.error('Unexpected error in VectorQueryTool execute', {\n            error: err,\n            errorMessage: err instanceof Error ? err.message : String(err),\n            errorStack: err instanceof Error ? err.stack : undefined,\n          });\n        }\n        return { relevantContext: [], sources: [] };\n      }\n    },\n    // Use any for output schema as the structure of the output causes type inference issues\n  }) as RagTool<typeof inputSchema, any>;\n};\n","/**\n * @deprecated These prompts have been moved to their respective vector store packages.\n * Import them directly from the vector store package instead:\n * - ASTRA_PROMPT: @mastra/astra/vector/prompt\n * - CHROMA_PROMPT: @mastra/chroma/vector/prompt\n * - LIBSQL_PROMPT: @mastra/libsql/vector/prompt\n * - PGVECTOR_PROMPT: @mastra/pg/vector/prompt\n * - PINECONE_PROMPT: @mastra/pinecone/vector/prompt\n * - QDRANT_PROMPT: @mastra/qdrant/vector/prompt\n * - UPSTASH_PROMPT: @mastra/upstash/vector/prompt\n * - VECTORIZE_PROMPT: @mastra/vectorize/vector/prompt\n * - MONGODB_PROMPT: @mastra/mongodb/vector/prompt\n */\n\n/** @deprecated Import from @mastra/astra instead */\nexport const ASTRA_PROMPT = `When querying Astra, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n- $all: Match all values in array\n  Example: { \"tags\": { \"$all\": [\"premium\", \"sale\"] } }\n\nLogical Operators:\n- $and: Logical AND (can be implicit or explicit)\n  Implicit Example: { \"price\": { \"$gt\": 100 }, \"category\": \"electronics\" }\n  Explicit Example: { \"$and\": [{ \"price\": { \"$gt\": 100 } }, { \"category\": \"electronics\" }] }\n- $or: Logical OR\n  Example: { \"$or\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n- $not: Logical NOT\n  Example: { \"$not\": { \"category\": \"electronics\" } }\n\nElement Operators:\n- $exists: Check if field exists\n  Example: { \"rating\": { \"$exists\": true } }\n\nSpecial Operators:\n- $size: Array length check\n  Example: { \"tags\": { \"$size\": 2 } }\n\nRestrictions:\n- Regex patterns are not supported\n- Only $and, $or, and $not logical operators are supported\n- Nested fields are supported using dot notation\n- Multiple conditions on the same field are supported with both implicit and explicit $and\n- Empty arrays in $in/$nin will return no results\n- A non-empty array is required for $all operator\n- Only logical operators ($and, $or, $not) can be used at the top level\n- All other operators must be used within a field condition\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Valid: { \"$and\": [...] }\n  Invalid: { \"$gt\": 100 }\n- Logical operators must contain field conditions, not direct operators\n  Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  Invalid: { \"$and\": [{ \"$gt\": 100 }] }\n- $not operator:\n  - Must be an object\n  - Cannot be empty\n  - Can be used at field level or top level\n  - Valid: { \"$not\": { \"field\": \"value\" } }\n  - Valid: { \"field\": { \"$not\": { \"$eq\": \"value\" } } }\n- Other logical operators ($and, $or):\n  - Can only be used at top level or nested within other logical operators\n  - Can not be used on a field level, or be nested inside a field\n  - Can not be used inside an operator\n  - Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  - Valid: { \"$or\": [{ \"$and\": [{ \"field\": { \"$gt\": 100 } }] }] }\n  - Invalid: { \"field\": { \"$and\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$or\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$gt\": { \"$and\": [{...}] } } }\n\nExample Complex Query:\n{\n  \"$and\": [\n    { \"category\": { \"$in\": [\"electronics\", \"computers\"] } },\n    { \"price\": { \"$gte\": 100, \"$lte\": 1000 } },\n    { \"tags\": { \"$all\": [\"premium\"] } },\n    { \"rating\": { \"$exists\": true, \"$gt\": 4 } },\n    { \"$or\": [\n      { \"stock\": { \"$gt\": 0 } },\n      { \"preorder\": true }\n    ]}\n  ]\n}`;\n\n/** @deprecated Import from @mastra/chroma instead */\nexport const CHROMA_PROMPT = `When querying Chroma, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n\nLogical Operators:\n- $and: Logical AND\n  Example: { \"$and\": [{ \"price\": { \"$gt\": 100 } }, { \"category\": \"electronics\" }] }\n- $or: Logical OR\n  Example: { \"$or\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n\nRestrictions:\n- Regex patterns are not supported\n- Element operators are not supported\n- Only $and and $or logical operators are supported\n- Nested fields are supported using dot notation\n- Multiple conditions on the same field are supported with both implicit and explicit $and\n- Empty arrays in $in/$nin will return no results\n- If multiple top-level fields exist, they're wrapped in $and\n- Only logical operators ($and, $or) can be used at the top level\n- All other operators must be used within a field condition\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Valid: { \"$and\": [...] }\n  Invalid: { \"$gt\": 100 }\n  Invalid: { \"$in\": [...] }\n- Logical operators must contain field conditions, not direct operators\n  Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  Invalid: { \"$and\": [{ \"$gt\": 100 }] }\n- Logical operators ($and, $or):\n  - Can only be used at top level or nested within other logical operators\n  - Can not be used on a field level, or be nested inside a field\n  - Can not be used inside an operator\n  - Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  - Valid: { \"$or\": [{ \"$and\": [{ \"field\": { \"$gt\": 100 } }] }] }\n  - Invalid: { \"field\": { \"$and\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$or\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$gt\": { \"$and\": [{...}] } } }\nExample Complex Query:\n{\n  \"$and\": [\n    { \"category\": { \"$in\": [\"electronics\", \"computers\"] } },\n    { \"price\": { \"$gte\": 100, \"$lte\": 1000 } },\n    { \"$or\": [\n      { \"inStock\": true },\n      { \"preorder\": true }\n    ]}\n  ]\n}`;\n\n/** @deprecated Import from @mastra/libsql instead */\nexport const LIBSQL_PROMPT = `When querying LibSQL Vector, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n- $all: Match all values in array\n  Example: { \"tags\": { \"$all\": [\"premium\", \"sale\"] } }\n- $elemMatch: Match array elements that meet all specified conditions\n  Example: { \"items\": { \"$elemMatch\": { \"price\": { \"$gt\": 100 } } } }\n- $contains: Check if array contains value\n  Example: { \"tags\": { \"$contains\": \"premium\" } }\n\nLogical Operators:\n- $and: Logical AND (implicit when using multiple conditions)\n  Example: { \"$and\": [{ \"price\": { \"$gt\": 100 } }, { \"category\": \"electronics\" }] }\n- $or: Logical OR\n  Example: { \"$or\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n- $not: Logical NOT\n  Example: { \"$not\": { \"category\": \"electronics\" } }\n- $nor: Logical NOR\n  Example: { \"$nor\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n\nElement Operators:\n- $exists: Check if field exists\n  Example: { \"rating\": { \"$exists\": true } }\n\nSpecial Operators:\n- $size: Array length check\n  Example: { \"tags\": { \"$size\": 2 } }\n\nRestrictions:\n- Regex patterns are not supported\n- Direct RegExp patterns will throw an error\n- Nested fields are supported using dot notation\n- Multiple conditions on the same field are supported with both implicit and explicit $and\n- Array operations work on array fields only\n- Basic operators handle array values as JSON strings\n- Empty arrays in conditions are handled gracefully\n- Only logical operators ($and, $or, $not, $nor) can be used at the top level\n- All other operators must be used within a field condition\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Valid: { \"$and\": [...] }\n  Invalid: { \"$gt\": 100 }\n  Invalid: { \"$contains\": \"value\" }\n- Logical operators must contain field conditions, not direct operators\n  Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  Invalid: { \"$and\": [{ \"$gt\": 100 }] }\n- $not operator:\n  - Must be an object\n  - Cannot be empty\n  - Can be used at field level or top level\n  - Valid: { \"$not\": { \"field\": \"value\" } }\n  - Valid: { \"field\": { \"$not\": { \"$eq\": \"value\" } } }\n- Other logical operators ($and, $or, $nor):\n  - Can only be used at top level or nested within other logical operators\n  - Can not be used on a field level, or be nested inside a field\n  - Can not be used inside an operator\n  - Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  - Valid: { \"$or\": [{ \"$and\": [{ \"field\": { \"$gt\": 100 } }] }] }\n  - Invalid: { \"field\": { \"$and\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$or\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$gt\": { \"$and\": [{...}] } } }\n- $elemMatch requires an object with conditions\n  Valid: { \"array\": { \"$elemMatch\": { \"field\": \"value\" } } }\n  Invalid: { \"array\": { \"$elemMatch\": \"value\" } }\n\nExample Complex Query:\n{\n  \"$and\": [\n    { \"category\": { \"$in\": [\"electronics\", \"computers\"] } },\n    { \"price\": { \"$gte\": 100, \"$lte\": 1000 } },\n    { \"tags\": { \"$all\": [\"premium\", \"sale\"] } },\n    { \"items\": { \"$elemMatch\": { \"price\": { \"$gt\": 50 }, \"inStock\": true } } },\n    { \"$or\": [\n      { \"stock\": { \"$gt\": 0 } },\n      { \"preorder\": true }\n    ]}\n  ]\n}`;\n\n/** @deprecated Import from @mastra/pg instead */\nexport const PGVECTOR_PROMPT = `When querying PG Vector, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n- $all: Match all values in array\n  Example: { \"tags\": { \"$all\": [\"premium\", \"sale\"] } }\n- $elemMatch: Match array elements that meet all specified conditions\n  Example: { \"items\": { \"$elemMatch\": { \"price\": { \"$gt\": 100 } } } }\n- $contains: Check if array contains value\n  Example: { \"tags\": { \"$contains\": \"premium\" } }\n\nLogical Operators:\n- $and: Logical AND\n  Example: { \"$and\": [{ \"price\": { \"$gt\": 100 } }, { \"category\": \"electronics\" }] }\n- $or: Logical OR\n  Example: { \"$or\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n- $not: Logical NOT\n  Example: { \"$not\": { \"category\": \"electronics\" } }\n- $nor: Logical NOR\n  Example: { \"$nor\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n\nElement Operators:\n- $exists: Check if field exists\n  Example: { \"rating\": { \"$exists\": true } }\n\nSpecial Operators:\n- $size: Array length check\n  Example: { \"tags\": { \"$size\": 2 } }\n- $regex: Pattern matching (PostgreSQL regex syntax)\n  Example: { \"name\": { \"$regex\": \"^iphone\" } }\n- $options: Regex options (used with $regex)\n  Example: { \"name\": { \"$regex\": \"iphone\", \"$options\": \"i\" } }\n\nRestrictions:\n- Direct RegExp patterns are supported\n- Nested fields are supported using dot notation\n- Multiple conditions on the same field are supported with both implicit and explicit $and\n- Array operations work on array fields only\n- Regex patterns must follow PostgreSQL syntax\n- Empty arrays in conditions are handled gracefully\n- Only logical operators ($and, $or, $not, $nor) can be used at the top level\n- All other operators must be used within a field condition\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Valid: { \"$and\": [...] }\n  Invalid: { \"$gt\": 100 }\n  Invalid: { \"$regex\": \"pattern\" }\n- Logical operators must contain field conditions, not direct operators\n  Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  Invalid: { \"$and\": [{ \"$gt\": 100 }] }\n- $not operator:\n  - Must be an object\n  - Cannot be empty\n  - Can be used at field level or top level\n  - Valid: { \"$not\": { \"field\": \"value\" } }\n  - Valid: { \"field\": { \"$not\": { \"$eq\": \"value\" } } }\n- Other logical operators ($and, $or, $nor):\n  - Can only be used at top level or nested within other logical operators\n  - Can not be used on a field level, or be nested inside a field\n  - Can not be used inside an operator\n  - Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  - Valid: { \"$or\": [{ \"$and\": [{ \"field\": { \"$gt\": 100 } }] }] }\n  - Invalid: { \"field\": { \"$and\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$or\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$gt\": { \"$and\": [{...}] } } }\n- $elemMatch requires an object with conditions\n  Valid: { \"array\": { \"$elemMatch\": { \"field\": \"value\" } } }\n  Invalid: { \"array\": { \"$elemMatch\": \"value\" } }\n\nExample Complex Query:\n{\n  \"$and\": [\n    { \"category\": { \"$in\": [\"electronics\", \"computers\"] } },\n    { \"price\": { \"$gte\": 100, \"$lte\": 1000 } },\n    { \"tags\": { \"$all\": [\"premium\", \"sale\"] } },\n    { \"items\": { \"$elemMatch\": { \"price\": { \"$gt\": 50 }, \"inStock\": true } } },\n    { \"$or\": [\n      { \"name\": { \"$regex\": \"^iphone\", \"$options\": \"i\" } },\n      { \"description\": { \"$regex\": \".*apple.*\" } }\n    ]}\n  ]\n}`;\n\n/** @deprecated Import from @mastra/pinecone instead */\nexport const PINECONE_PROMPT = `When querying Pinecone, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n- $all: Match all values in array\n  Example: { \"tags\": { \"$all\": [\"premium\", \"sale\"] } }\n\nLogical Operators:\n- $and: Logical AND (can be implicit or explicit)\n  Implicit Example: { \"price\": { \"$gt\": 100 }, \"category\": \"electronics\" }\n  Explicit Example: { \"$and\": [{ \"price\": { \"$gt\": 100 } }, { \"category\": \"electronics\" }] }\n- $or: Logical OR\n  Example: { \"$or\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n\nElement Operators:\n- $exists: Check if field exists\n  Example: { \"rating\": { \"$exists\": true } }\n\nRestrictions:\n- Regex patterns are not supported\n- Only $and and $or logical operators are supported at the top level\n- Empty arrays in $in/$nin will return no results\n- A non-empty array is required for $all operator\n- Nested fields are supported using dot notation\n- Multiple conditions on the same field are supported with both implicit and explicit $and\n- At least one key-value pair is required in filter object\n- Empty objects and undefined values are treated as no filter\n- Invalid types in comparison operators will throw errors\n- All non-logical operators must be used within a field condition\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Valid: { \"$and\": [...] }\n  Invalid: { \"$gt\": 100 }\n- Logical operators must contain field conditions, not direct operators\n  Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  Invalid: { \"$and\": [{ \"$gt\": 100 }] }\n- Logical operators ($and, $or):\n  - Can only be used at top level or nested within other logical operators\n  - Can not be used on a field level, or be nested inside a field\n  - Can not be used inside an operator\n  - Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  - Valid: { \"$or\": [{ \"$and\": [{ \"field\": { \"$gt\": 100 } }] }] }\n  - Invalid: { \"field\": { \"$and\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$or\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$gt\": { \"$and\": [{...}] } } }\nExample Complex Query:\n{\n  \"$and\": [\n    { \"category\": { \"$in\": [\"electronics\", \"computers\"] } },\n    { \"price\": { \"$gte\": 100, \"$lte\": 1000 } },\n    { \"tags\": { \"$all\": [\"premium\", \"sale\"] } },\n    { \"rating\": { \"$exists\": true, \"$gt\": 4 } },\n    { \"$or\": [\n      { \"stock\": { \"$gt\": 0 } },\n      { \"preorder\": true }\n    ]}\n  ]\n}`;\n\n/** @deprecated Import from @mastra/qdrant instead */\nexport const QDRANT_PROMPT = `When querying Qdrant, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n\nLogical Operators:\n- $and: Logical AND (implicit when using multiple conditions)\n  Example: { \"$and\": [{ \"price\": { \"$gt\": 100 } }, { \"category\": \"electronics\" }] }\n- $or: Logical OR\n  Example: { \"$or\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n- $not: Logical NOT\n  Example: { \"$not\": { \"category\": \"electronics\" } }\n\nElement Operators:\n- $exists: Check if field exists\n  Example: { \"rating\": { \"$exists\": true } }\n\nSpecial Operators:\n- $regex: Pattern matching\n  Example: { \"name\": { \"$regex\": \"iphone.*\" } }\n- $count: Array length/value count\n  Example: { \"tags\": { \"$count\": { \"$gt\": 2 } } }\n- $geo: Geographical filters (supports radius, box, polygon)\n  Example: {\n    \"location\": {\n      \"$geo\": {\n        \"type\": \"radius\",\n        \"center\": { \"lat\": 52.5, \"lon\": 13.4 },\n        \"radius\": 10000\n      }\n    }\n  }\n- $hasId: Match specific document IDs\n  Example: { \"$hasId\": [\"doc1\", \"doc2\"] }\n- $hasVector: Check vector existence\n  Example: { \"$hasVector\": \"\" }\n- $datetime: RFC 3339 datetime range\n  Example: {\n    \"created_at\": {\n      \"$datetime\": {\n        \"range\": {\n          \"gt\": \"2024-01-01T00:00:00Z\",\n          \"lt\": \"2024-12-31T23:59:59Z\"\n        }\n      }\n    }\n  }\n- $null: Check for null values\n  Example: { \"field\": { \"$null\": true } }\n- $empty: Check for empty values\n  Example: { \"array\": { \"$empty\": true } }\n- $nested: Nested object filters\n  Example: {\n    \"items[]\": {\n      \"$nested\": {\n        \"price\": { \"$gt\": 100 },\n        \"stock\": { \"$gt\": 0 }\n      }\n    }\n  }\n\nRestrictions:\n- Only logical operators ($and, $or, $not) and collection operators ($hasId, $hasVector) can be used at the top level\n- All other operators must be used within a field condition\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Valid: { \"$and\": [...] }\n  Valid: { \"$hasId\": [...] }\n  Invalid: { \"$gt\": 100 }\n- Nested fields are supported using dot notation\n- Array fields with nested objects use [] suffix: \"items[]\"\n- Geo filtering requires specific format for radius, box, or polygon\n- Datetime values must be in RFC 3339 format\n- Empty arrays in conditions are handled as empty values\n- Null values are handled with $null operator\n- Empty values are handled with $empty operator\n- $regex uses standard regex syntax\n- $count can only be used with numeric comparison operators\n- $nested requires an object with conditions\n- Logical operators must contain field conditions, not direct operators\n  Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  Invalid: { \"$and\": [{ \"$gt\": 100 }] }\n- $not operator:\n  - Must be an object\n  - Cannot be empty\n  - Can be used at field level or top level\n  - Valid: { \"$not\": { \"field\": \"value\" } }\n  - Valid: { \"field\": { \"$not\": { \"$eq\": \"value\" } } }\n- Other logical operators ($and, $or):\n  - Can only be used at top level or nested within other logical operators\n  - Can not be used on a field level, or be nested inside a field\n  - Can not be used inside an operator\n  - Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  - Valid: { \"$or\": [{ \"$and\": [{ \"field\": { \"$gt\": 100 } }] }] }\n  - Invalid: { \"field\": { \"$and\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$or\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$gt\": { \"$and\": [{...}] } } }\nExample Complex Query:\n{\n  \"$and\": [\n    { \"category\": { \"$in\": [\"electronics\"] } },\n    { \"price\": { \"$gt\": 100 } },\n    { \"location\": {\n      \"$geo\": {\n        \"type\": \"radius\",\n        \"center\": { \"lat\": 52.5, \"lon\": 13.4 },\n        \"radius\": 5000\n      }\n    }},\n    { \"items[]\": {\n      \"$nested\": {\n        \"price\": { \"$gt\": 50 },\n        \"stock\": { \"$gt\": 0 }\n      }\n    }},\n    { \"created_at\": {\n      \"$datetime\": {\n        \"range\": {\n          \"gt\": \"2024-01-01T00:00:00Z\"\n        }\n      }\n    }},\n    { \"$or\": [\n      { \"status\": { \"$ne\": \"discontinued\" } },\n      { \"clearance\": true }\n    ]}\n  ]\n}`;\n\n/** @deprecated Import from @mastra/upstash instead */\nexport const UPSTASH_PROMPT = `When querying Upstash Vector, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" } or { \"category\": { \"$eq\": \"electronics\" } }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n- $all: Matches all values in array\n  Example: { \"tags\": { \"$all\": [\"premium\", \"new\"] } }\n\nLogical Operators:\n- $and: Logical AND (implicit when using multiple conditions)\n  Example: { \"$and\": [{ \"price\": { \"$gt\": 100 } }, { \"category\": \"electronics\" }] }\n- $or: Logical OR\n  Example: { \"$or\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n- $not: Logical NOT\n  Example: { \"$not\": { \"category\": \"electronics\" } }\n- $nor: Logical NOR\n  Example: { \"$nor\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n\nElement Operators:\n- $exists: Check if field exists\n  Example: { \"rating\": { \"$exists\": true } }\n\nSpecial Operators:\n- $regex: Pattern matching using glob syntax (only as operator, not direct RegExp)\n  Example: { \"name\": { \"$regex\": \"iphone*\" } }\n- $contains: Check if array/string contains value\n  Example: { \"tags\": { \"$contains\": \"premium\" } }\n\nRestrictions:\n- Null/undefined values are not supported in any operator\n- Empty arrays are only supported in $in/$nin operators\n- Direct RegExp patterns are not supported, use $regex with glob syntax\n- Nested fields are supported using dot notation\n- Multiple conditions on same field are combined with AND\n- String values with quotes are automatically escaped\n- Only logical operators ($and, $or, $not, $nor) can be used at the top level\n- All other operators must be used within a field condition\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Valid: { \"$and\": [...] }\n  Invalid: { \"$gt\": 100 }\n- $regex uses glob syntax (*, ?) not standard regex patterns\n- $contains works on both arrays and string fields\n- Logical operators must contain field conditions, not direct operators\n  Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  Invalid: { \"$and\": [{ \"$gt\": 100 }] }\n- $not operator:\n  - Must be an object\n  - Cannot be empty\n  - Can be used at field level or top level\n  - Valid: { \"$not\": { \"field\": \"value\" } }\n  - Valid: { \"field\": { \"$not\": { \"$eq\": \"value\" } } }\n- Other logical operators ($and, $or, $nor):\n  - Can only be used at top level or nested within other logical operators\n  - Can not be used on a field level, or be nested inside a field\n  - Can not be used inside an operator\n  - Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  - Valid: { \"$or\": [{ \"$and\": [{ \"field\": { \"$gt\": 100 } }] }] }\n  - Invalid: { \"field\": { \"$and\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$or\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$gt\": { \"$and\": [{...}] } } }\nExample Complex Query:\n{\n  \"$and\": [\n    { \"category\": { \"$in\": [\"electronics\", \"computers\"] } },\n    { \"price\": { \"$gt\": 100, \"$lt\": 1000 } },\n    { \"tags\": { \"$all\": [\"premium\", \"new\"] } },\n    { \"name\": { \"$regex\": \"iphone*\" } },\n    { \"description\": { \"$contains\": \"latest\" } },\n    { \"$or\": [\n      { \"brand\": \"Apple\" },\n      { \"rating\": { \"$gte\": 4.5 } }\n    ]}\n  ]\n}`;\n\n/** @deprecated Import from @mastra/vectorize instead */\nexport const VECTORIZE_PROMPT = `When querying Vectorize, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n\nRestrictions:\n- Regex patterns are not supported\n- Logical operators are not supported\n- Element operators are not supported\n- Fields must have a flat structure, as nested fields are not supported\n- Multiple conditions on the same field are supported\n- Empty arrays in $in/$nin will return no results\n- Filter keys cannot be longer than 512 characters\n- Filter keys cannot contain invalid characters ($, \", empty)\n- Filter size is limited to prevent oversized queries\n- Invalid types in operators return no results instead of throwing errors\n- Empty objects are accepted in filters\n- Metadata must use flat structure with dot notation (no nested objects)\n- Must explicitly create metadata indexes for filterable fields (limit 10 per index)\n- Can only effectively filter on indexed metadata fields\n- Metadata values can be strings, numbers, booleans, or homogeneous arrays\n- No operators can be used at the top level (no logical operators supported)\n- All operators must be used within a field condition\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Invalid: { \"$gt\": 100 }\n  Invalid: { \"$in\": [...] }\n\nExample Complex Query:\n{\n  \"category\": { \"$in\": [\"electronics\", \"computers\"] },\n  \"price\": { \"$gte\": 100, \"$lte\": 1000 },\n  \"inStock\": true\n}`;\n\n/** @deprecated Import from @mastra/mongodb instead */\nexport const MONGODB_PROMPT = `When querying MongoDB, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n- $all: Match all values in array\n  Example: { \"tags\": { \"$all\": [\"premium\", \"sale\"] } }\n- $elemMatch: Match array elements by criteria\n  Example: { \"scores\": { \"$elemMatch\": { \"$gt\": 80 } } }\n\nLogical Operators:\n- $and: Logical AND (can be implicit or explicit)\n  Implicit Example: { \"price\": { \"$gt\": 100 }, \"category\": \"electronics\" }\n  Explicit Example: { \"$and\": [{ \"price\": { \"$gt\": 100 } }, { \"category\": \"electronics\" }] }\n- $or: Logical OR\n  Example: { \"$or\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n- $not: Logical NOT\n  Example: { \"field\": { \"$not\": { \"$eq\": \"value\" } } }\n- $nor: Logical NOR\n  Example: { \"$nor\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n\nElement Operators:\n- $exists: Check if field exists\n  Example: { \"rating\": { \"$exists\": true } }\n\nSpecial Operators:\n- $regex: Regular expression match\n  Example: { \"title\": { \"$regex\": \"^laptop\", \"$options\": \"i\" } }\n- $size: Array length check\n  Example: { \"tags\": { \"$size\": 2 } }\n\nUsage Notes:\n- You can use both 'filter' (for metadata fields) and 'documentFilter' (for document content fields).\n- Nested fields are supported using dot notation (e.g., \"metadata.author.name\").\n- Multiple conditions on the same field are supported with both implicit and explicit $and.\n- Empty arrays in $in/$nin will return no results.\n- All logical operators ($and, $or, $not, $nor) can be used at the top level or nested.\n- All other operators must be used within a field condition.\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Valid: { \"$and\": [...] }\n  Invalid: { \"$gt\": 100 }\n- $not operator:\n  - Must be an object\n  - Cannot be empty\n  - Can be used at field level or top level\n  - Valid: { \"$not\": { \"field\": \"value\" } }\n  - Valid: { \"field\": { \"$not\": { \"$eq\": \"value\" } } }\n- Logical operators must contain field conditions, not direct operators\n  Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  Invalid: { \"$and\": [{ \"$gt\": 100 }] }\n- Regex uses standard MongoDB regex syntax (with optional $options).\n- Metadata values can be strings, numbers, booleans, or arrays.\n- Metadata and document fields can be filtered in the same query.\n\nExample Complex Query:\n{\n  \"category\": { \"$in\": [\"electronics\", \"computers\"] },\n  \"price\": { \"$gte\": 100, \"$lte\": 1000 },\n  \"inStock\": true,\n  \"title\": { \"$regex\": \"laptop\", \"$options\": \"i\" },\n  \"$or\": [\n    { \"brand\": \"Apple\" },\n    { \"rating\": { \"$gte\": 4.5 } }\n  ]\n}\n`;\n"]}